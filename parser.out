Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> statement_list
Rule 2     statement_list -> statement KA statement_list
Rule 3     statement_list -> empty
Rule 4     KA -> SEMICOLON
Rule 5     KA -> empty
Rule 6     statement -> declaration
Rule 7     statement -> assignment
Rule 8     statement -> if_stmnt
Rule 9     statement -> while_stmt
Rule 10    statement -> function_call
Rule 11    statement -> expression
Rule 12    statement -> compound_types
Rule 13    statement -> compound_type_access
Rule 14    statement -> try_except
Rule 15    statement -> print
Rule 16    declaration -> VAR type assignment
Rule 17    L -> statement
Rule 18    L -> ID LPAREN data RPAREN
Rule 19    assignment -> ID ASSIGN L
Rule 20    type -> INT
Rule 21    type -> BOOL
Rule 22    type -> STR
Rule 23    compound_types -> A ID ASSIGN LPAREN data RPAREN
Rule 24    A -> TUPLE
Rule 25    A -> LIST
Rule 26    data -> expression data
Rule 27    data -> COMMA data
Rule 28    data -> empty
Rule 29    compound_type_access -> Z F
Rule 30    compound_type_access -> ID LSPAREN expression RSPAREN
Rule 31    Z -> ID DOT
Rule 32    F -> CON LPAREN factor RPAREN
Rule 33    F -> FRONT
Rule 34    F -> ADD LPAREN factor RPAREN
Rule 35    F -> REAR
Rule 36    F -> SIZE
Rule 37    F -> DELETE
Rule 38    F -> SUBSTR LPAREN factor COMMA factor RPAREN
Rule 39    F -> empty
Rule 40    if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T
Rule 41    T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K
Rule 42    T -> empty
Rule 43    K -> ELSE BEGIN statement_list END
Rule 44    K -> empty
Rule 45    while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END
Rule 46    function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
Rule 47    parameter_list -> type ID parameter_list
Rule 48    parameter_list -> COMMA parameter_list
Rule 49    parameter_list -> empty
Rule 50    condition -> expression comparison_operator expression
Rule 51    comparison_operator -> EQEQ
Rule 52    comparison_operator -> NOTEQ
Rule 53    comparison_operator -> LT
Rule 54    comparison_operator -> GT
Rule 55    comparison_operator -> LTEQ
Rule 56    comparison_operator -> GTEQ
Rule 57    expression -> expression binary_operator expression
Rule 58    expression -> term
Rule 59    binary_operator -> PLUS
Rule 60    binary_operator -> MINUS
Rule 61    binary_operator -> MUL
Rule 62    binary_operator -> DIV
Rule 63    binary_operator -> REM
Rule 64    term -> factor
Rule 65    term -> term unary_operator
Rule 66    unary_operator -> PLUSPLUS
Rule 67    unary_operator -> MINUSMINUS
Rule 68    factor -> ID
Rule 69    factor -> NUMBER
Rule 70    factor -> STRING
Rule 71    factor -> TRUE
Rule 72    factor -> FALSE
Rule 73    factor -> LPAREN expression RPAREN
Rule 74    try_except -> TRY COLON x EXCEPT COLON x
Rule 75    x -> BEGIN statement_list END
Rule 76    print -> ZOUT LPAREN y RPAREN
Rule 77    y -> expression
Rule 78    y -> compound_type_access
Rule 79    empty -> <empty>

Terminals, with rules where they appear

ADD                  : 34
ASSIGN               : 19 23
BEGIN                : 40 41 43 45 46 75
BOOL                 : 21
COLON                : 74 74
COMMA                : 27 38 48
CON                  : 32
DELETE               : 37
DIV                  : 62
DOT                  : 31
ELIF                 : 41
ELSE                 : 43
END                  : 40 41 43 45 46 75
EQEQ                 : 51
EXCEPT               : 74
FALSE                : 72
FRONT                : 33
FUNC                 : 46
GT                   : 54
GTEQ                 : 56
ID                   : 18 19 23 30 31 46 47 68
IF                   : 40
INT                  : 20
LIST                 : 25
LPAREN               : 18 23 32 34 38 40 41 45 46 73 76
LSPAREN              : 30
LT                   : 53
LTEQ                 : 55
MINUS                : 60
MINUSMINUS           : 67
MUL                  : 61
NOTEQ                : 52
NUMBER               : 69
PLUS                 : 59
PLUSPLUS             : 66
REAR                 : 35
REM                  : 63
RETURN               : 46
RPAREN               : 18 23 32 34 38 40 41 45 46 73 76
RSPAREN              : 30
SEMICOLON            : 4 46
SIZE                 : 36
STR                  : 22
STRING               : 70
SUBSTR               : 38
TRUE                 : 71
TRY                  : 74
TUPLE                : 24
VAR                  : 16
WHILE                : 45
ZOUT                 : 76
error                : 

Nonterminals, with rules where they appear

A                    : 23
F                    : 29
K                    : 41
KA                   : 2
L                    : 19
T                    : 40
Z                    : 29
assignment           : 7 16
binary_operator      : 57
comparison_operator  : 50
compound_type_access : 13 78
compound_types       : 12
condition            : 40 41 45
data                 : 18 23 26 27 46
declaration          : 6
empty                : 3 5 28 39 42 44 49
expression           : 11 26 30 50 50 57 57 73 77
factor               : 32 34 38 38 64
function_call        : 10
if_stmnt             : 8
parameter_list       : 46 47 48
print                : 15
start                : 0
statement            : 2 17
statement_list       : 1 2 40 41 43 45 46 75
term                 : 58 65
try_except           : 14
type                 : 16 47
unary_operator       : 65
while_stmt           : 9
x                    : 74 74
y                    : 76

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . statement_list
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    $end            reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    start                          shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 1

    (0) S' -> start .



state 2

    (1) start -> statement_list .

    $end            reduce using rule 1 (start -> statement_list .)


state 3

    (2) statement_list -> statement . KA statement_list
    (4) KA -> . SEMICOLON
    (5) KA -> . empty
    (79) empty -> .

    SEMICOLON       shift and go to state 34
    VAR             reduce using rule 79 (empty -> .)
    ID              reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    FUNC            reduce using rule 79 (empty -> .)
    TRY             reduce using rule 79 (empty -> .)
    ZOUT            reduce using rule 79 (empty -> .)
    TUPLE           reduce using rule 79 (empty -> .)
    LIST            reduce using rule 79 (empty -> .)
    NUMBER          reduce using rule 79 (empty -> .)
    STRING          reduce using rule 79 (empty -> .)
    TRUE            reduce using rule 79 (empty -> .)
    FALSE           reduce using rule 79 (empty -> .)
    LPAREN          reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)

    KA                             shift and go to state 33
    empty                          shift and go to state 35

state 4

    (3) statement_list -> empty .

    $end            reduce using rule 3 (statement_list -> empty .)
    END             reduce using rule 3 (statement_list -> empty .)
    RETURN          reduce using rule 3 (statement_list -> empty .)


state 5

    (6) statement -> declaration .

    SEMICOLON       reduce using rule 6 (statement -> declaration .)
    VAR             reduce using rule 6 (statement -> declaration .)
    ID              reduce using rule 6 (statement -> declaration .)
    IF              reduce using rule 6 (statement -> declaration .)
    WHILE           reduce using rule 6 (statement -> declaration .)
    FUNC            reduce using rule 6 (statement -> declaration .)
    TRY             reduce using rule 6 (statement -> declaration .)
    ZOUT            reduce using rule 6 (statement -> declaration .)
    TUPLE           reduce using rule 6 (statement -> declaration .)
    LIST            reduce using rule 6 (statement -> declaration .)
    NUMBER          reduce using rule 6 (statement -> declaration .)
    STRING          reduce using rule 6 (statement -> declaration .)
    TRUE            reduce using rule 6 (statement -> declaration .)
    FALSE           reduce using rule 6 (statement -> declaration .)
    LPAREN          reduce using rule 6 (statement -> declaration .)
    $end            reduce using rule 6 (statement -> declaration .)
    END             reduce using rule 6 (statement -> declaration .)
    RETURN          reduce using rule 6 (statement -> declaration .)


state 6

    (7) statement -> assignment .

    SEMICOLON       reduce using rule 7 (statement -> assignment .)
    VAR             reduce using rule 7 (statement -> assignment .)
    ID              reduce using rule 7 (statement -> assignment .)
    IF              reduce using rule 7 (statement -> assignment .)
    WHILE           reduce using rule 7 (statement -> assignment .)
    FUNC            reduce using rule 7 (statement -> assignment .)
    TRY             reduce using rule 7 (statement -> assignment .)
    ZOUT            reduce using rule 7 (statement -> assignment .)
    TUPLE           reduce using rule 7 (statement -> assignment .)
    LIST            reduce using rule 7 (statement -> assignment .)
    NUMBER          reduce using rule 7 (statement -> assignment .)
    STRING          reduce using rule 7 (statement -> assignment .)
    TRUE            reduce using rule 7 (statement -> assignment .)
    FALSE           reduce using rule 7 (statement -> assignment .)
    LPAREN          reduce using rule 7 (statement -> assignment .)
    $end            reduce using rule 7 (statement -> assignment .)
    END             reduce using rule 7 (statement -> assignment .)
    RETURN          reduce using rule 7 (statement -> assignment .)


state 7

    (8) statement -> if_stmnt .

    SEMICOLON       reduce using rule 8 (statement -> if_stmnt .)
    VAR             reduce using rule 8 (statement -> if_stmnt .)
    ID              reduce using rule 8 (statement -> if_stmnt .)
    IF              reduce using rule 8 (statement -> if_stmnt .)
    WHILE           reduce using rule 8 (statement -> if_stmnt .)
    FUNC            reduce using rule 8 (statement -> if_stmnt .)
    TRY             reduce using rule 8 (statement -> if_stmnt .)
    ZOUT            reduce using rule 8 (statement -> if_stmnt .)
    TUPLE           reduce using rule 8 (statement -> if_stmnt .)
    LIST            reduce using rule 8 (statement -> if_stmnt .)
    NUMBER          reduce using rule 8 (statement -> if_stmnt .)
    STRING          reduce using rule 8 (statement -> if_stmnt .)
    TRUE            reduce using rule 8 (statement -> if_stmnt .)
    FALSE           reduce using rule 8 (statement -> if_stmnt .)
    LPAREN          reduce using rule 8 (statement -> if_stmnt .)
    $end            reduce using rule 8 (statement -> if_stmnt .)
    END             reduce using rule 8 (statement -> if_stmnt .)
    RETURN          reduce using rule 8 (statement -> if_stmnt .)


state 8

    (9) statement -> while_stmt .

    SEMICOLON       reduce using rule 9 (statement -> while_stmt .)
    VAR             reduce using rule 9 (statement -> while_stmt .)
    ID              reduce using rule 9 (statement -> while_stmt .)
    IF              reduce using rule 9 (statement -> while_stmt .)
    WHILE           reduce using rule 9 (statement -> while_stmt .)
    FUNC            reduce using rule 9 (statement -> while_stmt .)
    TRY             reduce using rule 9 (statement -> while_stmt .)
    ZOUT            reduce using rule 9 (statement -> while_stmt .)
    TUPLE           reduce using rule 9 (statement -> while_stmt .)
    LIST            reduce using rule 9 (statement -> while_stmt .)
    NUMBER          reduce using rule 9 (statement -> while_stmt .)
    STRING          reduce using rule 9 (statement -> while_stmt .)
    TRUE            reduce using rule 9 (statement -> while_stmt .)
    FALSE           reduce using rule 9 (statement -> while_stmt .)
    LPAREN          reduce using rule 9 (statement -> while_stmt .)
    $end            reduce using rule 9 (statement -> while_stmt .)
    END             reduce using rule 9 (statement -> while_stmt .)
    RETURN          reduce using rule 9 (statement -> while_stmt .)


state 9

    (10) statement -> function_call .

    SEMICOLON       reduce using rule 10 (statement -> function_call .)
    VAR             reduce using rule 10 (statement -> function_call .)
    ID              reduce using rule 10 (statement -> function_call .)
    IF              reduce using rule 10 (statement -> function_call .)
    WHILE           reduce using rule 10 (statement -> function_call .)
    FUNC            reduce using rule 10 (statement -> function_call .)
    TRY             reduce using rule 10 (statement -> function_call .)
    ZOUT            reduce using rule 10 (statement -> function_call .)
    TUPLE           reduce using rule 10 (statement -> function_call .)
    LIST            reduce using rule 10 (statement -> function_call .)
    NUMBER          reduce using rule 10 (statement -> function_call .)
    STRING          reduce using rule 10 (statement -> function_call .)
    TRUE            reduce using rule 10 (statement -> function_call .)
    FALSE           reduce using rule 10 (statement -> function_call .)
    LPAREN          reduce using rule 10 (statement -> function_call .)
    $end            reduce using rule 10 (statement -> function_call .)
    END             reduce using rule 10 (statement -> function_call .)
    RETURN          reduce using rule 10 (statement -> function_call .)


state 10

    (11) statement -> expression .
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    SEMICOLON       reduce using rule 11 (statement -> expression .)
    VAR             reduce using rule 11 (statement -> expression .)
    ID              reduce using rule 11 (statement -> expression .)
    IF              reduce using rule 11 (statement -> expression .)
    WHILE           reduce using rule 11 (statement -> expression .)
    FUNC            reduce using rule 11 (statement -> expression .)
    TRY             reduce using rule 11 (statement -> expression .)
    ZOUT            reduce using rule 11 (statement -> expression .)
    TUPLE           reduce using rule 11 (statement -> expression .)
    LIST            reduce using rule 11 (statement -> expression .)
    NUMBER          reduce using rule 11 (statement -> expression .)
    STRING          reduce using rule 11 (statement -> expression .)
    TRUE            reduce using rule 11 (statement -> expression .)
    FALSE           reduce using rule 11 (statement -> expression .)
    LPAREN          reduce using rule 11 (statement -> expression .)
    $end            reduce using rule 11 (statement -> expression .)
    END             reduce using rule 11 (statement -> expression .)
    RETURN          reduce using rule 11 (statement -> expression .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    binary_operator                shift and go to state 36

state 11

    (12) statement -> compound_types .

    SEMICOLON       reduce using rule 12 (statement -> compound_types .)
    VAR             reduce using rule 12 (statement -> compound_types .)
    ID              reduce using rule 12 (statement -> compound_types .)
    IF              reduce using rule 12 (statement -> compound_types .)
    WHILE           reduce using rule 12 (statement -> compound_types .)
    FUNC            reduce using rule 12 (statement -> compound_types .)
    TRY             reduce using rule 12 (statement -> compound_types .)
    ZOUT            reduce using rule 12 (statement -> compound_types .)
    TUPLE           reduce using rule 12 (statement -> compound_types .)
    LIST            reduce using rule 12 (statement -> compound_types .)
    NUMBER          reduce using rule 12 (statement -> compound_types .)
    STRING          reduce using rule 12 (statement -> compound_types .)
    TRUE            reduce using rule 12 (statement -> compound_types .)
    FALSE           reduce using rule 12 (statement -> compound_types .)
    LPAREN          reduce using rule 12 (statement -> compound_types .)
    $end            reduce using rule 12 (statement -> compound_types .)
    END             reduce using rule 12 (statement -> compound_types .)
    RETURN          reduce using rule 12 (statement -> compound_types .)


state 12

    (13) statement -> compound_type_access .

    SEMICOLON       reduce using rule 13 (statement -> compound_type_access .)
    VAR             reduce using rule 13 (statement -> compound_type_access .)
    ID              reduce using rule 13 (statement -> compound_type_access .)
    IF              reduce using rule 13 (statement -> compound_type_access .)
    WHILE           reduce using rule 13 (statement -> compound_type_access .)
    FUNC            reduce using rule 13 (statement -> compound_type_access .)
    TRY             reduce using rule 13 (statement -> compound_type_access .)
    ZOUT            reduce using rule 13 (statement -> compound_type_access .)
    TUPLE           reduce using rule 13 (statement -> compound_type_access .)
    LIST            reduce using rule 13 (statement -> compound_type_access .)
    NUMBER          reduce using rule 13 (statement -> compound_type_access .)
    STRING          reduce using rule 13 (statement -> compound_type_access .)
    TRUE            reduce using rule 13 (statement -> compound_type_access .)
    FALSE           reduce using rule 13 (statement -> compound_type_access .)
    LPAREN          reduce using rule 13 (statement -> compound_type_access .)
    $end            reduce using rule 13 (statement -> compound_type_access .)
    END             reduce using rule 13 (statement -> compound_type_access .)
    RETURN          reduce using rule 13 (statement -> compound_type_access .)


state 13

    (14) statement -> try_except .

    SEMICOLON       reduce using rule 14 (statement -> try_except .)
    VAR             reduce using rule 14 (statement -> try_except .)
    ID              reduce using rule 14 (statement -> try_except .)
    IF              reduce using rule 14 (statement -> try_except .)
    WHILE           reduce using rule 14 (statement -> try_except .)
    FUNC            reduce using rule 14 (statement -> try_except .)
    TRY             reduce using rule 14 (statement -> try_except .)
    ZOUT            reduce using rule 14 (statement -> try_except .)
    TUPLE           reduce using rule 14 (statement -> try_except .)
    LIST            reduce using rule 14 (statement -> try_except .)
    NUMBER          reduce using rule 14 (statement -> try_except .)
    STRING          reduce using rule 14 (statement -> try_except .)
    TRUE            reduce using rule 14 (statement -> try_except .)
    FALSE           reduce using rule 14 (statement -> try_except .)
    LPAREN          reduce using rule 14 (statement -> try_except .)
    $end            reduce using rule 14 (statement -> try_except .)
    END             reduce using rule 14 (statement -> try_except .)
    RETURN          reduce using rule 14 (statement -> try_except .)


state 14

    (15) statement -> print .

    SEMICOLON       reduce using rule 15 (statement -> print .)
    VAR             reduce using rule 15 (statement -> print .)
    ID              reduce using rule 15 (statement -> print .)
    IF              reduce using rule 15 (statement -> print .)
    WHILE           reduce using rule 15 (statement -> print .)
    FUNC            reduce using rule 15 (statement -> print .)
    TRY             reduce using rule 15 (statement -> print .)
    ZOUT            reduce using rule 15 (statement -> print .)
    TUPLE           reduce using rule 15 (statement -> print .)
    LIST            reduce using rule 15 (statement -> print .)
    NUMBER          reduce using rule 15 (statement -> print .)
    STRING          reduce using rule 15 (statement -> print .)
    TRUE            reduce using rule 15 (statement -> print .)
    FALSE           reduce using rule 15 (statement -> print .)
    LPAREN          reduce using rule 15 (statement -> print .)
    $end            reduce using rule 15 (statement -> print .)
    END             reduce using rule 15 (statement -> print .)
    RETURN          reduce using rule 15 (statement -> print .)


state 15

    (16) declaration -> VAR . type assignment
    (20) type -> . INT
    (21) type -> . BOOL
    (22) type -> . STR

    INT             shift and go to state 43
    BOOL            shift and go to state 44
    STR             shift and go to state 45

    type                           shift and go to state 42

state 16

    (19) assignment -> ID . ASSIGN L
    (30) compound_type_access -> ID . LSPAREN expression RSPAREN
    (31) Z -> ID . DOT
    (68) factor -> ID .

    ASSIGN          shift and go to state 46
    LSPAREN         shift and go to state 47
    DOT             shift and go to state 48
    PLUSPLUS        reduce using rule 68 (factor -> ID .)
    MINUSMINUS      reduce using rule 68 (factor -> ID .)
    PLUS            reduce using rule 68 (factor -> ID .)
    MINUS           reduce using rule 68 (factor -> ID .)
    MUL             reduce using rule 68 (factor -> ID .)
    DIV             reduce using rule 68 (factor -> ID .)
    REM             reduce using rule 68 (factor -> ID .)
    SEMICOLON       reduce using rule 68 (factor -> ID .)
    VAR             reduce using rule 68 (factor -> ID .)
    ID              reduce using rule 68 (factor -> ID .)
    IF              reduce using rule 68 (factor -> ID .)
    WHILE           reduce using rule 68 (factor -> ID .)
    FUNC            reduce using rule 68 (factor -> ID .)
    TRY             reduce using rule 68 (factor -> ID .)
    ZOUT            reduce using rule 68 (factor -> ID .)
    TUPLE           reduce using rule 68 (factor -> ID .)
    LIST            reduce using rule 68 (factor -> ID .)
    NUMBER          reduce using rule 68 (factor -> ID .)
    STRING          reduce using rule 68 (factor -> ID .)
    TRUE            reduce using rule 68 (factor -> ID .)
    FALSE           reduce using rule 68 (factor -> ID .)
    LPAREN          reduce using rule 68 (factor -> ID .)
    $end            reduce using rule 68 (factor -> ID .)
    END             reduce using rule 68 (factor -> ID .)
    RETURN          reduce using rule 68 (factor -> ID .)


state 17

    (40) if_stmnt -> IF . LPAREN condition RPAREN BEGIN statement_list END T

    LPAREN          shift and go to state 49


state 18

    (73) factor -> LPAREN . expression RPAREN
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    expression                     shift and go to state 50
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 19

    (45) while_stmt -> WHILE . LPAREN condition RPAREN BEGIN statement_list END

    LPAREN          shift and go to state 52


state 20

    (46) function_call -> FUNC . ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END

    ID              shift and go to state 53


state 21

    (58) expression -> term .
    (65) term -> term . unary_operator
    (66) unary_operator -> . PLUSPLUS
    (67) unary_operator -> . MINUSMINUS

    PLUS            reduce using rule 58 (expression -> term .)
    MINUS           reduce using rule 58 (expression -> term .)
    MUL             reduce using rule 58 (expression -> term .)
    DIV             reduce using rule 58 (expression -> term .)
    REM             reduce using rule 58 (expression -> term .)
    SEMICOLON       reduce using rule 58 (expression -> term .)
    VAR             reduce using rule 58 (expression -> term .)
    ID              reduce using rule 58 (expression -> term .)
    IF              reduce using rule 58 (expression -> term .)
    WHILE           reduce using rule 58 (expression -> term .)
    FUNC            reduce using rule 58 (expression -> term .)
    TRY             reduce using rule 58 (expression -> term .)
    ZOUT            reduce using rule 58 (expression -> term .)
    TUPLE           reduce using rule 58 (expression -> term .)
    LIST            reduce using rule 58 (expression -> term .)
    NUMBER          reduce using rule 58 (expression -> term .)
    STRING          reduce using rule 58 (expression -> term .)
    TRUE            reduce using rule 58 (expression -> term .)
    FALSE           reduce using rule 58 (expression -> term .)
    LPAREN          reduce using rule 58 (expression -> term .)
    $end            reduce using rule 58 (expression -> term .)
    RPAREN          reduce using rule 58 (expression -> term .)
    END             reduce using rule 58 (expression -> term .)
    RETURN          reduce using rule 58 (expression -> term .)
    RSPAREN         reduce using rule 58 (expression -> term .)
    EQEQ            reduce using rule 58 (expression -> term .)
    NOTEQ           reduce using rule 58 (expression -> term .)
    LT              reduce using rule 58 (expression -> term .)
    GT              reduce using rule 58 (expression -> term .)
    LTEQ            reduce using rule 58 (expression -> term .)
    GTEQ            reduce using rule 58 (expression -> term .)
    COMMA           reduce using rule 58 (expression -> term .)
    PLUSPLUS        shift and go to state 55
    MINUSMINUS      shift and go to state 56

    unary_operator                 shift and go to state 54

state 22

    (23) compound_types -> A . ID ASSIGN LPAREN data RPAREN

    ID              shift and go to state 57


state 23

    (29) compound_type_access -> Z . F
    (32) F -> . CON LPAREN factor RPAREN
    (33) F -> . FRONT
    (34) F -> . ADD LPAREN factor RPAREN
    (35) F -> . REAR
    (36) F -> . SIZE
    (37) F -> . DELETE
    (38) F -> . SUBSTR LPAREN factor COMMA factor RPAREN
    (39) F -> . empty
    (79) empty -> .

    CON             shift and go to state 59
    FRONT           shift and go to state 60
    ADD             shift and go to state 61
    REAR            shift and go to state 62
    SIZE            shift and go to state 63
    DELETE          shift and go to state 64
    SUBSTR          shift and go to state 65
    SEMICOLON       reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)
    ID              reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    FUNC            reduce using rule 79 (empty -> .)
    TRY             reduce using rule 79 (empty -> .)
    ZOUT            reduce using rule 79 (empty -> .)
    TUPLE           reduce using rule 79 (empty -> .)
    LIST            reduce using rule 79 (empty -> .)
    NUMBER          reduce using rule 79 (empty -> .)
    STRING          reduce using rule 79 (empty -> .)
    TRUE            reduce using rule 79 (empty -> .)
    FALSE           reduce using rule 79 (empty -> .)
    LPAREN          reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)
    RPAREN          reduce using rule 79 (empty -> .)

    F                              shift and go to state 58
    empty                          shift and go to state 66

state 24

    (74) try_except -> TRY . COLON x EXCEPT COLON x

    COLON           shift and go to state 67


state 25

    (76) print -> ZOUT . LPAREN y RPAREN

    LPAREN          shift and go to state 68


state 26

    (64) term -> factor .

    PLUSPLUS        reduce using rule 64 (term -> factor .)
    MINUSMINUS      reduce using rule 64 (term -> factor .)
    PLUS            reduce using rule 64 (term -> factor .)
    MINUS           reduce using rule 64 (term -> factor .)
    MUL             reduce using rule 64 (term -> factor .)
    DIV             reduce using rule 64 (term -> factor .)
    REM             reduce using rule 64 (term -> factor .)
    SEMICOLON       reduce using rule 64 (term -> factor .)
    VAR             reduce using rule 64 (term -> factor .)
    ID              reduce using rule 64 (term -> factor .)
    IF              reduce using rule 64 (term -> factor .)
    WHILE           reduce using rule 64 (term -> factor .)
    FUNC            reduce using rule 64 (term -> factor .)
    TRY             reduce using rule 64 (term -> factor .)
    ZOUT            reduce using rule 64 (term -> factor .)
    TUPLE           reduce using rule 64 (term -> factor .)
    LIST            reduce using rule 64 (term -> factor .)
    NUMBER          reduce using rule 64 (term -> factor .)
    STRING          reduce using rule 64 (term -> factor .)
    TRUE            reduce using rule 64 (term -> factor .)
    FALSE           reduce using rule 64 (term -> factor .)
    LPAREN          reduce using rule 64 (term -> factor .)
    $end            reduce using rule 64 (term -> factor .)
    RPAREN          reduce using rule 64 (term -> factor .)
    END             reduce using rule 64 (term -> factor .)
    RETURN          reduce using rule 64 (term -> factor .)
    RSPAREN         reduce using rule 64 (term -> factor .)
    EQEQ            reduce using rule 64 (term -> factor .)
    NOTEQ           reduce using rule 64 (term -> factor .)
    LT              reduce using rule 64 (term -> factor .)
    GT              reduce using rule 64 (term -> factor .)
    LTEQ            reduce using rule 64 (term -> factor .)
    GTEQ            reduce using rule 64 (term -> factor .)
    COMMA           reduce using rule 64 (term -> factor .)


state 27

    (24) A -> TUPLE .

    ID              reduce using rule 24 (A -> TUPLE .)


state 28

    (25) A -> LIST .

    ID              reduce using rule 25 (A -> LIST .)


state 29

    (69) factor -> NUMBER .

    PLUSPLUS        reduce using rule 69 (factor -> NUMBER .)
    MINUSMINUS      reduce using rule 69 (factor -> NUMBER .)
    PLUS            reduce using rule 69 (factor -> NUMBER .)
    MINUS           reduce using rule 69 (factor -> NUMBER .)
    MUL             reduce using rule 69 (factor -> NUMBER .)
    DIV             reduce using rule 69 (factor -> NUMBER .)
    REM             reduce using rule 69 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 69 (factor -> NUMBER .)
    VAR             reduce using rule 69 (factor -> NUMBER .)
    ID              reduce using rule 69 (factor -> NUMBER .)
    IF              reduce using rule 69 (factor -> NUMBER .)
    WHILE           reduce using rule 69 (factor -> NUMBER .)
    FUNC            reduce using rule 69 (factor -> NUMBER .)
    TRY             reduce using rule 69 (factor -> NUMBER .)
    ZOUT            reduce using rule 69 (factor -> NUMBER .)
    TUPLE           reduce using rule 69 (factor -> NUMBER .)
    LIST            reduce using rule 69 (factor -> NUMBER .)
    NUMBER          reduce using rule 69 (factor -> NUMBER .)
    STRING          reduce using rule 69 (factor -> NUMBER .)
    TRUE            reduce using rule 69 (factor -> NUMBER .)
    FALSE           reduce using rule 69 (factor -> NUMBER .)
    LPAREN          reduce using rule 69 (factor -> NUMBER .)
    $end            reduce using rule 69 (factor -> NUMBER .)
    RPAREN          reduce using rule 69 (factor -> NUMBER .)
    END             reduce using rule 69 (factor -> NUMBER .)
    RETURN          reduce using rule 69 (factor -> NUMBER .)
    RSPAREN         reduce using rule 69 (factor -> NUMBER .)
    EQEQ            reduce using rule 69 (factor -> NUMBER .)
    NOTEQ           reduce using rule 69 (factor -> NUMBER .)
    LT              reduce using rule 69 (factor -> NUMBER .)
    GT              reduce using rule 69 (factor -> NUMBER .)
    LTEQ            reduce using rule 69 (factor -> NUMBER .)
    GTEQ            reduce using rule 69 (factor -> NUMBER .)
    COMMA           reduce using rule 69 (factor -> NUMBER .)


state 30

    (70) factor -> STRING .

    PLUSPLUS        reduce using rule 70 (factor -> STRING .)
    MINUSMINUS      reduce using rule 70 (factor -> STRING .)
    PLUS            reduce using rule 70 (factor -> STRING .)
    MINUS           reduce using rule 70 (factor -> STRING .)
    MUL             reduce using rule 70 (factor -> STRING .)
    DIV             reduce using rule 70 (factor -> STRING .)
    REM             reduce using rule 70 (factor -> STRING .)
    SEMICOLON       reduce using rule 70 (factor -> STRING .)
    VAR             reduce using rule 70 (factor -> STRING .)
    ID              reduce using rule 70 (factor -> STRING .)
    IF              reduce using rule 70 (factor -> STRING .)
    WHILE           reduce using rule 70 (factor -> STRING .)
    FUNC            reduce using rule 70 (factor -> STRING .)
    TRY             reduce using rule 70 (factor -> STRING .)
    ZOUT            reduce using rule 70 (factor -> STRING .)
    TUPLE           reduce using rule 70 (factor -> STRING .)
    LIST            reduce using rule 70 (factor -> STRING .)
    NUMBER          reduce using rule 70 (factor -> STRING .)
    STRING          reduce using rule 70 (factor -> STRING .)
    TRUE            reduce using rule 70 (factor -> STRING .)
    FALSE           reduce using rule 70 (factor -> STRING .)
    LPAREN          reduce using rule 70 (factor -> STRING .)
    $end            reduce using rule 70 (factor -> STRING .)
    RPAREN          reduce using rule 70 (factor -> STRING .)
    END             reduce using rule 70 (factor -> STRING .)
    RETURN          reduce using rule 70 (factor -> STRING .)
    RSPAREN         reduce using rule 70 (factor -> STRING .)
    EQEQ            reduce using rule 70 (factor -> STRING .)
    NOTEQ           reduce using rule 70 (factor -> STRING .)
    LT              reduce using rule 70 (factor -> STRING .)
    GT              reduce using rule 70 (factor -> STRING .)
    LTEQ            reduce using rule 70 (factor -> STRING .)
    GTEQ            reduce using rule 70 (factor -> STRING .)
    COMMA           reduce using rule 70 (factor -> STRING .)


state 31

    (71) factor -> TRUE .

    PLUSPLUS        reduce using rule 71 (factor -> TRUE .)
    MINUSMINUS      reduce using rule 71 (factor -> TRUE .)
    PLUS            reduce using rule 71 (factor -> TRUE .)
    MINUS           reduce using rule 71 (factor -> TRUE .)
    MUL             reduce using rule 71 (factor -> TRUE .)
    DIV             reduce using rule 71 (factor -> TRUE .)
    REM             reduce using rule 71 (factor -> TRUE .)
    SEMICOLON       reduce using rule 71 (factor -> TRUE .)
    VAR             reduce using rule 71 (factor -> TRUE .)
    ID              reduce using rule 71 (factor -> TRUE .)
    IF              reduce using rule 71 (factor -> TRUE .)
    WHILE           reduce using rule 71 (factor -> TRUE .)
    FUNC            reduce using rule 71 (factor -> TRUE .)
    TRY             reduce using rule 71 (factor -> TRUE .)
    ZOUT            reduce using rule 71 (factor -> TRUE .)
    TUPLE           reduce using rule 71 (factor -> TRUE .)
    LIST            reduce using rule 71 (factor -> TRUE .)
    NUMBER          reduce using rule 71 (factor -> TRUE .)
    STRING          reduce using rule 71 (factor -> TRUE .)
    TRUE            reduce using rule 71 (factor -> TRUE .)
    FALSE           reduce using rule 71 (factor -> TRUE .)
    LPAREN          reduce using rule 71 (factor -> TRUE .)
    $end            reduce using rule 71 (factor -> TRUE .)
    RPAREN          reduce using rule 71 (factor -> TRUE .)
    END             reduce using rule 71 (factor -> TRUE .)
    RETURN          reduce using rule 71 (factor -> TRUE .)
    RSPAREN         reduce using rule 71 (factor -> TRUE .)
    EQEQ            reduce using rule 71 (factor -> TRUE .)
    NOTEQ           reduce using rule 71 (factor -> TRUE .)
    LT              reduce using rule 71 (factor -> TRUE .)
    GT              reduce using rule 71 (factor -> TRUE .)
    LTEQ            reduce using rule 71 (factor -> TRUE .)
    GTEQ            reduce using rule 71 (factor -> TRUE .)
    COMMA           reduce using rule 71 (factor -> TRUE .)


state 32

    (72) factor -> FALSE .

    PLUSPLUS        reduce using rule 72 (factor -> FALSE .)
    MINUSMINUS      reduce using rule 72 (factor -> FALSE .)
    PLUS            reduce using rule 72 (factor -> FALSE .)
    MINUS           reduce using rule 72 (factor -> FALSE .)
    MUL             reduce using rule 72 (factor -> FALSE .)
    DIV             reduce using rule 72 (factor -> FALSE .)
    REM             reduce using rule 72 (factor -> FALSE .)
    SEMICOLON       reduce using rule 72 (factor -> FALSE .)
    VAR             reduce using rule 72 (factor -> FALSE .)
    ID              reduce using rule 72 (factor -> FALSE .)
    IF              reduce using rule 72 (factor -> FALSE .)
    WHILE           reduce using rule 72 (factor -> FALSE .)
    FUNC            reduce using rule 72 (factor -> FALSE .)
    TRY             reduce using rule 72 (factor -> FALSE .)
    ZOUT            reduce using rule 72 (factor -> FALSE .)
    TUPLE           reduce using rule 72 (factor -> FALSE .)
    LIST            reduce using rule 72 (factor -> FALSE .)
    NUMBER          reduce using rule 72 (factor -> FALSE .)
    STRING          reduce using rule 72 (factor -> FALSE .)
    TRUE            reduce using rule 72 (factor -> FALSE .)
    FALSE           reduce using rule 72 (factor -> FALSE .)
    LPAREN          reduce using rule 72 (factor -> FALSE .)
    $end            reduce using rule 72 (factor -> FALSE .)
    RPAREN          reduce using rule 72 (factor -> FALSE .)
    END             reduce using rule 72 (factor -> FALSE .)
    RETURN          reduce using rule 72 (factor -> FALSE .)
    RSPAREN         reduce using rule 72 (factor -> FALSE .)
    EQEQ            reduce using rule 72 (factor -> FALSE .)
    NOTEQ           reduce using rule 72 (factor -> FALSE .)
    LT              reduce using rule 72 (factor -> FALSE .)
    GT              reduce using rule 72 (factor -> FALSE .)
    LTEQ            reduce using rule 72 (factor -> FALSE .)
    GTEQ            reduce using rule 72 (factor -> FALSE .)
    COMMA           reduce using rule 72 (factor -> FALSE .)


state 33

    (2) statement_list -> statement KA . statement_list
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    $end            reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement                      shift and go to state 3
    statement_list                 shift and go to state 69
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 34

    (4) KA -> SEMICOLON .

    VAR             reduce using rule 4 (KA -> SEMICOLON .)
    ID              reduce using rule 4 (KA -> SEMICOLON .)
    IF              reduce using rule 4 (KA -> SEMICOLON .)
    WHILE           reduce using rule 4 (KA -> SEMICOLON .)
    FUNC            reduce using rule 4 (KA -> SEMICOLON .)
    TRY             reduce using rule 4 (KA -> SEMICOLON .)
    ZOUT            reduce using rule 4 (KA -> SEMICOLON .)
    TUPLE           reduce using rule 4 (KA -> SEMICOLON .)
    LIST            reduce using rule 4 (KA -> SEMICOLON .)
    NUMBER          reduce using rule 4 (KA -> SEMICOLON .)
    STRING          reduce using rule 4 (KA -> SEMICOLON .)
    TRUE            reduce using rule 4 (KA -> SEMICOLON .)
    FALSE           reduce using rule 4 (KA -> SEMICOLON .)
    LPAREN          reduce using rule 4 (KA -> SEMICOLON .)
    $end            reduce using rule 4 (KA -> SEMICOLON .)
    END             reduce using rule 4 (KA -> SEMICOLON .)
    RETURN          reduce using rule 4 (KA -> SEMICOLON .)


state 35

    (5) KA -> empty .

    VAR             reduce using rule 5 (KA -> empty .)
    ID              reduce using rule 5 (KA -> empty .)
    IF              reduce using rule 5 (KA -> empty .)
    WHILE           reduce using rule 5 (KA -> empty .)
    FUNC            reduce using rule 5 (KA -> empty .)
    TRY             reduce using rule 5 (KA -> empty .)
    ZOUT            reduce using rule 5 (KA -> empty .)
    TUPLE           reduce using rule 5 (KA -> empty .)
    LIST            reduce using rule 5 (KA -> empty .)
    NUMBER          reduce using rule 5 (KA -> empty .)
    STRING          reduce using rule 5 (KA -> empty .)
    TRUE            reduce using rule 5 (KA -> empty .)
    FALSE           reduce using rule 5 (KA -> empty .)
    LPAREN          reduce using rule 5 (KA -> empty .)
    $end            reduce using rule 5 (KA -> empty .)
    END             reduce using rule 5 (KA -> empty .)
    RETURN          reduce using rule 5 (KA -> empty .)


state 36

    (57) expression -> expression binary_operator . expression
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    expression                     shift and go to state 70
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 37

    (59) binary_operator -> PLUS .

    ID              reduce using rule 59 (binary_operator -> PLUS .)
    NUMBER          reduce using rule 59 (binary_operator -> PLUS .)
    STRING          reduce using rule 59 (binary_operator -> PLUS .)
    TRUE            reduce using rule 59 (binary_operator -> PLUS .)
    FALSE           reduce using rule 59 (binary_operator -> PLUS .)
    LPAREN          reduce using rule 59 (binary_operator -> PLUS .)


state 38

    (60) binary_operator -> MINUS .

    ID              reduce using rule 60 (binary_operator -> MINUS .)
    NUMBER          reduce using rule 60 (binary_operator -> MINUS .)
    STRING          reduce using rule 60 (binary_operator -> MINUS .)
    TRUE            reduce using rule 60 (binary_operator -> MINUS .)
    FALSE           reduce using rule 60 (binary_operator -> MINUS .)
    LPAREN          reduce using rule 60 (binary_operator -> MINUS .)


state 39

    (61) binary_operator -> MUL .

    ID              reduce using rule 61 (binary_operator -> MUL .)
    NUMBER          reduce using rule 61 (binary_operator -> MUL .)
    STRING          reduce using rule 61 (binary_operator -> MUL .)
    TRUE            reduce using rule 61 (binary_operator -> MUL .)
    FALSE           reduce using rule 61 (binary_operator -> MUL .)
    LPAREN          reduce using rule 61 (binary_operator -> MUL .)


state 40

    (62) binary_operator -> DIV .

    ID              reduce using rule 62 (binary_operator -> DIV .)
    NUMBER          reduce using rule 62 (binary_operator -> DIV .)
    STRING          reduce using rule 62 (binary_operator -> DIV .)
    TRUE            reduce using rule 62 (binary_operator -> DIV .)
    FALSE           reduce using rule 62 (binary_operator -> DIV .)
    LPAREN          reduce using rule 62 (binary_operator -> DIV .)


state 41

    (63) binary_operator -> REM .

    ID              reduce using rule 63 (binary_operator -> REM .)
    NUMBER          reduce using rule 63 (binary_operator -> REM .)
    STRING          reduce using rule 63 (binary_operator -> REM .)
    TRUE            reduce using rule 63 (binary_operator -> REM .)
    FALSE           reduce using rule 63 (binary_operator -> REM .)
    LPAREN          reduce using rule 63 (binary_operator -> REM .)


state 42

    (16) declaration -> VAR type . assignment
    (19) assignment -> . ID ASSIGN L

    ID              shift and go to state 72

    assignment                     shift and go to state 71

state 43

    (20) type -> INT .

    ID              reduce using rule 20 (type -> INT .)


state 44

    (21) type -> BOOL .

    ID              reduce using rule 21 (type -> BOOL .)


state 45

    (22) type -> STR .

    ID              reduce using rule 22 (type -> STR .)


state 46

    (19) assignment -> ID ASSIGN . L
    (17) L -> . statement
    (18) L -> . ID LPAREN data RPAREN
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 73
    VAR             shift and go to state 15
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    L                              shift and go to state 74
    statement                      shift and go to state 75
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 47

    (30) compound_type_access -> ID LSPAREN . expression RSPAREN
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    expression                     shift and go to state 76
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 48

    (31) Z -> ID DOT .

    CON             reduce using rule 31 (Z -> ID DOT .)
    FRONT           reduce using rule 31 (Z -> ID DOT .)
    ADD             reduce using rule 31 (Z -> ID DOT .)
    REAR            reduce using rule 31 (Z -> ID DOT .)
    SIZE            reduce using rule 31 (Z -> ID DOT .)
    DELETE          reduce using rule 31 (Z -> ID DOT .)
    SUBSTR          reduce using rule 31 (Z -> ID DOT .)
    SEMICOLON       reduce using rule 31 (Z -> ID DOT .)
    VAR             reduce using rule 31 (Z -> ID DOT .)
    ID              reduce using rule 31 (Z -> ID DOT .)
    IF              reduce using rule 31 (Z -> ID DOT .)
    WHILE           reduce using rule 31 (Z -> ID DOT .)
    FUNC            reduce using rule 31 (Z -> ID DOT .)
    TRY             reduce using rule 31 (Z -> ID DOT .)
    ZOUT            reduce using rule 31 (Z -> ID DOT .)
    TUPLE           reduce using rule 31 (Z -> ID DOT .)
    LIST            reduce using rule 31 (Z -> ID DOT .)
    NUMBER          reduce using rule 31 (Z -> ID DOT .)
    STRING          reduce using rule 31 (Z -> ID DOT .)
    TRUE            reduce using rule 31 (Z -> ID DOT .)
    FALSE           reduce using rule 31 (Z -> ID DOT .)
    LPAREN          reduce using rule 31 (Z -> ID DOT .)
    $end            reduce using rule 31 (Z -> ID DOT .)
    END             reduce using rule 31 (Z -> ID DOT .)
    RETURN          reduce using rule 31 (Z -> ID DOT .)
    RPAREN          reduce using rule 31 (Z -> ID DOT .)


state 49

    (40) if_stmnt -> IF LPAREN . condition RPAREN BEGIN statement_list END T
    (50) condition -> . expression comparison_operator expression
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    condition                      shift and go to state 77
    expression                     shift and go to state 78
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 50

    (73) factor -> LPAREN expression . RPAREN
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    RPAREN          shift and go to state 79
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    binary_operator                shift and go to state 36

state 51

    (68) factor -> ID .

    PLUSPLUS        reduce using rule 68 (factor -> ID .)
    MINUSMINUS      reduce using rule 68 (factor -> ID .)
    RPAREN          reduce using rule 68 (factor -> ID .)
    PLUS            reduce using rule 68 (factor -> ID .)
    MINUS           reduce using rule 68 (factor -> ID .)
    MUL             reduce using rule 68 (factor -> ID .)
    DIV             reduce using rule 68 (factor -> ID .)
    REM             reduce using rule 68 (factor -> ID .)
    SEMICOLON       reduce using rule 68 (factor -> ID .)
    VAR             reduce using rule 68 (factor -> ID .)
    ID              reduce using rule 68 (factor -> ID .)
    IF              reduce using rule 68 (factor -> ID .)
    WHILE           reduce using rule 68 (factor -> ID .)
    FUNC            reduce using rule 68 (factor -> ID .)
    TRY             reduce using rule 68 (factor -> ID .)
    ZOUT            reduce using rule 68 (factor -> ID .)
    TUPLE           reduce using rule 68 (factor -> ID .)
    LIST            reduce using rule 68 (factor -> ID .)
    NUMBER          reduce using rule 68 (factor -> ID .)
    STRING          reduce using rule 68 (factor -> ID .)
    TRUE            reduce using rule 68 (factor -> ID .)
    FALSE           reduce using rule 68 (factor -> ID .)
    LPAREN          reduce using rule 68 (factor -> ID .)
    $end            reduce using rule 68 (factor -> ID .)
    END             reduce using rule 68 (factor -> ID .)
    RETURN          reduce using rule 68 (factor -> ID .)
    RSPAREN         reduce using rule 68 (factor -> ID .)
    EQEQ            reduce using rule 68 (factor -> ID .)
    NOTEQ           reduce using rule 68 (factor -> ID .)
    LT              reduce using rule 68 (factor -> ID .)
    GT              reduce using rule 68 (factor -> ID .)
    LTEQ            reduce using rule 68 (factor -> ID .)
    GTEQ            reduce using rule 68 (factor -> ID .)
    COMMA           reduce using rule 68 (factor -> ID .)


state 52

    (45) while_stmt -> WHILE LPAREN . condition RPAREN BEGIN statement_list END
    (50) condition -> . expression comparison_operator expression
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    condition                      shift and go to state 80
    expression                     shift and go to state 78
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 53

    (46) function_call -> FUNC ID . LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END

    LPAREN          shift and go to state 81


state 54

    (65) term -> term unary_operator .

    PLUSPLUS        reduce using rule 65 (term -> term unary_operator .)
    MINUSMINUS      reduce using rule 65 (term -> term unary_operator .)
    PLUS            reduce using rule 65 (term -> term unary_operator .)
    MINUS           reduce using rule 65 (term -> term unary_operator .)
    MUL             reduce using rule 65 (term -> term unary_operator .)
    DIV             reduce using rule 65 (term -> term unary_operator .)
    REM             reduce using rule 65 (term -> term unary_operator .)
    SEMICOLON       reduce using rule 65 (term -> term unary_operator .)
    VAR             reduce using rule 65 (term -> term unary_operator .)
    ID              reduce using rule 65 (term -> term unary_operator .)
    IF              reduce using rule 65 (term -> term unary_operator .)
    WHILE           reduce using rule 65 (term -> term unary_operator .)
    FUNC            reduce using rule 65 (term -> term unary_operator .)
    TRY             reduce using rule 65 (term -> term unary_operator .)
    ZOUT            reduce using rule 65 (term -> term unary_operator .)
    TUPLE           reduce using rule 65 (term -> term unary_operator .)
    LIST            reduce using rule 65 (term -> term unary_operator .)
    NUMBER          reduce using rule 65 (term -> term unary_operator .)
    STRING          reduce using rule 65 (term -> term unary_operator .)
    TRUE            reduce using rule 65 (term -> term unary_operator .)
    FALSE           reduce using rule 65 (term -> term unary_operator .)
    LPAREN          reduce using rule 65 (term -> term unary_operator .)
    $end            reduce using rule 65 (term -> term unary_operator .)
    RPAREN          reduce using rule 65 (term -> term unary_operator .)
    END             reduce using rule 65 (term -> term unary_operator .)
    RETURN          reduce using rule 65 (term -> term unary_operator .)
    RSPAREN         reduce using rule 65 (term -> term unary_operator .)
    EQEQ            reduce using rule 65 (term -> term unary_operator .)
    NOTEQ           reduce using rule 65 (term -> term unary_operator .)
    LT              reduce using rule 65 (term -> term unary_operator .)
    GT              reduce using rule 65 (term -> term unary_operator .)
    LTEQ            reduce using rule 65 (term -> term unary_operator .)
    GTEQ            reduce using rule 65 (term -> term unary_operator .)
    COMMA           reduce using rule 65 (term -> term unary_operator .)


state 55

    (66) unary_operator -> PLUSPLUS .

    PLUSPLUS        reduce using rule 66 (unary_operator -> PLUSPLUS .)
    MINUSMINUS      reduce using rule 66 (unary_operator -> PLUSPLUS .)
    PLUS            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    MINUS           reduce using rule 66 (unary_operator -> PLUSPLUS .)
    MUL             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    DIV             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    REM             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    SEMICOLON       reduce using rule 66 (unary_operator -> PLUSPLUS .)
    VAR             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    ID              reduce using rule 66 (unary_operator -> PLUSPLUS .)
    IF              reduce using rule 66 (unary_operator -> PLUSPLUS .)
    WHILE           reduce using rule 66 (unary_operator -> PLUSPLUS .)
    FUNC            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    TRY             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    ZOUT            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    TUPLE           reduce using rule 66 (unary_operator -> PLUSPLUS .)
    LIST            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    NUMBER          reduce using rule 66 (unary_operator -> PLUSPLUS .)
    STRING          reduce using rule 66 (unary_operator -> PLUSPLUS .)
    TRUE            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    FALSE           reduce using rule 66 (unary_operator -> PLUSPLUS .)
    LPAREN          reduce using rule 66 (unary_operator -> PLUSPLUS .)
    $end            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    RPAREN          reduce using rule 66 (unary_operator -> PLUSPLUS .)
    END             reduce using rule 66 (unary_operator -> PLUSPLUS .)
    RETURN          reduce using rule 66 (unary_operator -> PLUSPLUS .)
    RSPAREN         reduce using rule 66 (unary_operator -> PLUSPLUS .)
    EQEQ            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    NOTEQ           reduce using rule 66 (unary_operator -> PLUSPLUS .)
    LT              reduce using rule 66 (unary_operator -> PLUSPLUS .)
    GT              reduce using rule 66 (unary_operator -> PLUSPLUS .)
    LTEQ            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    GTEQ            reduce using rule 66 (unary_operator -> PLUSPLUS .)
    COMMA           reduce using rule 66 (unary_operator -> PLUSPLUS .)


state 56

    (67) unary_operator -> MINUSMINUS .

    PLUSPLUS        reduce using rule 67 (unary_operator -> MINUSMINUS .)
    MINUSMINUS      reduce using rule 67 (unary_operator -> MINUSMINUS .)
    PLUS            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    MINUS           reduce using rule 67 (unary_operator -> MINUSMINUS .)
    MUL             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    DIV             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    REM             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    SEMICOLON       reduce using rule 67 (unary_operator -> MINUSMINUS .)
    VAR             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    ID              reduce using rule 67 (unary_operator -> MINUSMINUS .)
    IF              reduce using rule 67 (unary_operator -> MINUSMINUS .)
    WHILE           reduce using rule 67 (unary_operator -> MINUSMINUS .)
    FUNC            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    TRY             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    ZOUT            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    TUPLE           reduce using rule 67 (unary_operator -> MINUSMINUS .)
    LIST            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    NUMBER          reduce using rule 67 (unary_operator -> MINUSMINUS .)
    STRING          reduce using rule 67 (unary_operator -> MINUSMINUS .)
    TRUE            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    FALSE           reduce using rule 67 (unary_operator -> MINUSMINUS .)
    LPAREN          reduce using rule 67 (unary_operator -> MINUSMINUS .)
    $end            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    RPAREN          reduce using rule 67 (unary_operator -> MINUSMINUS .)
    END             reduce using rule 67 (unary_operator -> MINUSMINUS .)
    RETURN          reduce using rule 67 (unary_operator -> MINUSMINUS .)
    RSPAREN         reduce using rule 67 (unary_operator -> MINUSMINUS .)
    EQEQ            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    NOTEQ           reduce using rule 67 (unary_operator -> MINUSMINUS .)
    LT              reduce using rule 67 (unary_operator -> MINUSMINUS .)
    GT              reduce using rule 67 (unary_operator -> MINUSMINUS .)
    LTEQ            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    GTEQ            reduce using rule 67 (unary_operator -> MINUSMINUS .)
    COMMA           reduce using rule 67 (unary_operator -> MINUSMINUS .)


state 57

    (23) compound_types -> A ID . ASSIGN LPAREN data RPAREN

    ASSIGN          shift and go to state 82


state 58

    (29) compound_type_access -> Z F .

    SEMICOLON       reduce using rule 29 (compound_type_access -> Z F .)
    VAR             reduce using rule 29 (compound_type_access -> Z F .)
    ID              reduce using rule 29 (compound_type_access -> Z F .)
    IF              reduce using rule 29 (compound_type_access -> Z F .)
    WHILE           reduce using rule 29 (compound_type_access -> Z F .)
    FUNC            reduce using rule 29 (compound_type_access -> Z F .)
    TRY             reduce using rule 29 (compound_type_access -> Z F .)
    ZOUT            reduce using rule 29 (compound_type_access -> Z F .)
    TUPLE           reduce using rule 29 (compound_type_access -> Z F .)
    LIST            reduce using rule 29 (compound_type_access -> Z F .)
    NUMBER          reduce using rule 29 (compound_type_access -> Z F .)
    STRING          reduce using rule 29 (compound_type_access -> Z F .)
    TRUE            reduce using rule 29 (compound_type_access -> Z F .)
    FALSE           reduce using rule 29 (compound_type_access -> Z F .)
    LPAREN          reduce using rule 29 (compound_type_access -> Z F .)
    $end            reduce using rule 29 (compound_type_access -> Z F .)
    END             reduce using rule 29 (compound_type_access -> Z F .)
    RETURN          reduce using rule 29 (compound_type_access -> Z F .)
    RPAREN          reduce using rule 29 (compound_type_access -> Z F .)


state 59

    (32) F -> CON . LPAREN factor RPAREN

    LPAREN          shift and go to state 83


state 60

    (33) F -> FRONT .

    SEMICOLON       reduce using rule 33 (F -> FRONT .)
    VAR             reduce using rule 33 (F -> FRONT .)
    ID              reduce using rule 33 (F -> FRONT .)
    IF              reduce using rule 33 (F -> FRONT .)
    WHILE           reduce using rule 33 (F -> FRONT .)
    FUNC            reduce using rule 33 (F -> FRONT .)
    TRY             reduce using rule 33 (F -> FRONT .)
    ZOUT            reduce using rule 33 (F -> FRONT .)
    TUPLE           reduce using rule 33 (F -> FRONT .)
    LIST            reduce using rule 33 (F -> FRONT .)
    NUMBER          reduce using rule 33 (F -> FRONT .)
    STRING          reduce using rule 33 (F -> FRONT .)
    TRUE            reduce using rule 33 (F -> FRONT .)
    FALSE           reduce using rule 33 (F -> FRONT .)
    LPAREN          reduce using rule 33 (F -> FRONT .)
    $end            reduce using rule 33 (F -> FRONT .)
    END             reduce using rule 33 (F -> FRONT .)
    RETURN          reduce using rule 33 (F -> FRONT .)
    RPAREN          reduce using rule 33 (F -> FRONT .)


state 61

    (34) F -> ADD . LPAREN factor RPAREN

    LPAREN          shift and go to state 84


state 62

    (35) F -> REAR .

    SEMICOLON       reduce using rule 35 (F -> REAR .)
    VAR             reduce using rule 35 (F -> REAR .)
    ID              reduce using rule 35 (F -> REAR .)
    IF              reduce using rule 35 (F -> REAR .)
    WHILE           reduce using rule 35 (F -> REAR .)
    FUNC            reduce using rule 35 (F -> REAR .)
    TRY             reduce using rule 35 (F -> REAR .)
    ZOUT            reduce using rule 35 (F -> REAR .)
    TUPLE           reduce using rule 35 (F -> REAR .)
    LIST            reduce using rule 35 (F -> REAR .)
    NUMBER          reduce using rule 35 (F -> REAR .)
    STRING          reduce using rule 35 (F -> REAR .)
    TRUE            reduce using rule 35 (F -> REAR .)
    FALSE           reduce using rule 35 (F -> REAR .)
    LPAREN          reduce using rule 35 (F -> REAR .)
    $end            reduce using rule 35 (F -> REAR .)
    END             reduce using rule 35 (F -> REAR .)
    RETURN          reduce using rule 35 (F -> REAR .)
    RPAREN          reduce using rule 35 (F -> REAR .)


state 63

    (36) F -> SIZE .

    SEMICOLON       reduce using rule 36 (F -> SIZE .)
    VAR             reduce using rule 36 (F -> SIZE .)
    ID              reduce using rule 36 (F -> SIZE .)
    IF              reduce using rule 36 (F -> SIZE .)
    WHILE           reduce using rule 36 (F -> SIZE .)
    FUNC            reduce using rule 36 (F -> SIZE .)
    TRY             reduce using rule 36 (F -> SIZE .)
    ZOUT            reduce using rule 36 (F -> SIZE .)
    TUPLE           reduce using rule 36 (F -> SIZE .)
    LIST            reduce using rule 36 (F -> SIZE .)
    NUMBER          reduce using rule 36 (F -> SIZE .)
    STRING          reduce using rule 36 (F -> SIZE .)
    TRUE            reduce using rule 36 (F -> SIZE .)
    FALSE           reduce using rule 36 (F -> SIZE .)
    LPAREN          reduce using rule 36 (F -> SIZE .)
    $end            reduce using rule 36 (F -> SIZE .)
    END             reduce using rule 36 (F -> SIZE .)
    RETURN          reduce using rule 36 (F -> SIZE .)
    RPAREN          reduce using rule 36 (F -> SIZE .)


state 64

    (37) F -> DELETE .

    SEMICOLON       reduce using rule 37 (F -> DELETE .)
    VAR             reduce using rule 37 (F -> DELETE .)
    ID              reduce using rule 37 (F -> DELETE .)
    IF              reduce using rule 37 (F -> DELETE .)
    WHILE           reduce using rule 37 (F -> DELETE .)
    FUNC            reduce using rule 37 (F -> DELETE .)
    TRY             reduce using rule 37 (F -> DELETE .)
    ZOUT            reduce using rule 37 (F -> DELETE .)
    TUPLE           reduce using rule 37 (F -> DELETE .)
    LIST            reduce using rule 37 (F -> DELETE .)
    NUMBER          reduce using rule 37 (F -> DELETE .)
    STRING          reduce using rule 37 (F -> DELETE .)
    TRUE            reduce using rule 37 (F -> DELETE .)
    FALSE           reduce using rule 37 (F -> DELETE .)
    LPAREN          reduce using rule 37 (F -> DELETE .)
    $end            reduce using rule 37 (F -> DELETE .)
    END             reduce using rule 37 (F -> DELETE .)
    RETURN          reduce using rule 37 (F -> DELETE .)
    RPAREN          reduce using rule 37 (F -> DELETE .)


state 65

    (38) F -> SUBSTR . LPAREN factor COMMA factor RPAREN

    LPAREN          shift and go to state 85


state 66

    (39) F -> empty .

    SEMICOLON       reduce using rule 39 (F -> empty .)
    VAR             reduce using rule 39 (F -> empty .)
    ID              reduce using rule 39 (F -> empty .)
    IF              reduce using rule 39 (F -> empty .)
    WHILE           reduce using rule 39 (F -> empty .)
    FUNC            reduce using rule 39 (F -> empty .)
    TRY             reduce using rule 39 (F -> empty .)
    ZOUT            reduce using rule 39 (F -> empty .)
    TUPLE           reduce using rule 39 (F -> empty .)
    LIST            reduce using rule 39 (F -> empty .)
    NUMBER          reduce using rule 39 (F -> empty .)
    STRING          reduce using rule 39 (F -> empty .)
    TRUE            reduce using rule 39 (F -> empty .)
    FALSE           reduce using rule 39 (F -> empty .)
    LPAREN          reduce using rule 39 (F -> empty .)
    $end            reduce using rule 39 (F -> empty .)
    END             reduce using rule 39 (F -> empty .)
    RETURN          reduce using rule 39 (F -> empty .)
    RPAREN          reduce using rule 39 (F -> empty .)


state 67

    (74) try_except -> TRY COLON . x EXCEPT COLON x
    (75) x -> . BEGIN statement_list END

    BEGIN           shift and go to state 87

    x                              shift and go to state 86

state 68

    (76) print -> ZOUT LPAREN . y RPAREN
    (77) y -> . expression
    (78) y -> . compound_type_access
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 91
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    y                              shift and go to state 88
    expression                     shift and go to state 89
    compound_type_access           shift and go to state 90
    term                           shift and go to state 21
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 69

    (2) statement_list -> statement KA statement_list .

    $end            reduce using rule 2 (statement_list -> statement KA statement_list .)
    END             reduce using rule 2 (statement_list -> statement KA statement_list .)
    RETURN          reduce using rule 2 (statement_list -> statement KA statement_list .)


state 70

    (57) expression -> expression binary_operator expression .
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for REM resolved as shift
    SEMICOLON       reduce using rule 57 (expression -> expression binary_operator expression .)
    VAR             reduce using rule 57 (expression -> expression binary_operator expression .)
    ID              reduce using rule 57 (expression -> expression binary_operator expression .)
    IF              reduce using rule 57 (expression -> expression binary_operator expression .)
    WHILE           reduce using rule 57 (expression -> expression binary_operator expression .)
    FUNC            reduce using rule 57 (expression -> expression binary_operator expression .)
    TRY             reduce using rule 57 (expression -> expression binary_operator expression .)
    ZOUT            reduce using rule 57 (expression -> expression binary_operator expression .)
    TUPLE           reduce using rule 57 (expression -> expression binary_operator expression .)
    LIST            reduce using rule 57 (expression -> expression binary_operator expression .)
    NUMBER          reduce using rule 57 (expression -> expression binary_operator expression .)
    STRING          reduce using rule 57 (expression -> expression binary_operator expression .)
    TRUE            reduce using rule 57 (expression -> expression binary_operator expression .)
    FALSE           reduce using rule 57 (expression -> expression binary_operator expression .)
    LPAREN          reduce using rule 57 (expression -> expression binary_operator expression .)
    $end            reduce using rule 57 (expression -> expression binary_operator expression .)
    RPAREN          reduce using rule 57 (expression -> expression binary_operator expression .)
    END             reduce using rule 57 (expression -> expression binary_operator expression .)
    RETURN          reduce using rule 57 (expression -> expression binary_operator expression .)
    RSPAREN         reduce using rule 57 (expression -> expression binary_operator expression .)
    EQEQ            reduce using rule 57 (expression -> expression binary_operator expression .)
    NOTEQ           reduce using rule 57 (expression -> expression binary_operator expression .)
    LT              reduce using rule 57 (expression -> expression binary_operator expression .)
    GT              reduce using rule 57 (expression -> expression binary_operator expression .)
    LTEQ            reduce using rule 57 (expression -> expression binary_operator expression .)
    GTEQ            reduce using rule 57 (expression -> expression binary_operator expression .)
    COMMA           reduce using rule 57 (expression -> expression binary_operator expression .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

  ! PLUS            [ reduce using rule 57 (expression -> expression binary_operator expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression binary_operator expression .) ]
  ! MUL             [ reduce using rule 57 (expression -> expression binary_operator expression .) ]
  ! DIV             [ reduce using rule 57 (expression -> expression binary_operator expression .) ]
  ! REM             [ reduce using rule 57 (expression -> expression binary_operator expression .) ]

    binary_operator                shift and go to state 36

state 71

    (16) declaration -> VAR type assignment .

    SEMICOLON       reduce using rule 16 (declaration -> VAR type assignment .)
    VAR             reduce using rule 16 (declaration -> VAR type assignment .)
    ID              reduce using rule 16 (declaration -> VAR type assignment .)
    IF              reduce using rule 16 (declaration -> VAR type assignment .)
    WHILE           reduce using rule 16 (declaration -> VAR type assignment .)
    FUNC            reduce using rule 16 (declaration -> VAR type assignment .)
    TRY             reduce using rule 16 (declaration -> VAR type assignment .)
    ZOUT            reduce using rule 16 (declaration -> VAR type assignment .)
    TUPLE           reduce using rule 16 (declaration -> VAR type assignment .)
    LIST            reduce using rule 16 (declaration -> VAR type assignment .)
    NUMBER          reduce using rule 16 (declaration -> VAR type assignment .)
    STRING          reduce using rule 16 (declaration -> VAR type assignment .)
    TRUE            reduce using rule 16 (declaration -> VAR type assignment .)
    FALSE           reduce using rule 16 (declaration -> VAR type assignment .)
    LPAREN          reduce using rule 16 (declaration -> VAR type assignment .)
    $end            reduce using rule 16 (declaration -> VAR type assignment .)
    END             reduce using rule 16 (declaration -> VAR type assignment .)
    RETURN          reduce using rule 16 (declaration -> VAR type assignment .)


state 72

    (19) assignment -> ID . ASSIGN L

    ASSIGN          shift and go to state 46


state 73

    (18) L -> ID . LPAREN data RPAREN
    (19) assignment -> ID . ASSIGN L
    (30) compound_type_access -> ID . LSPAREN expression RSPAREN
    (31) Z -> ID . DOT
    (68) factor -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 92
    ASSIGN          shift and go to state 46
    LSPAREN         shift and go to state 47
    DOT             shift and go to state 48
    PLUSPLUS        reduce using rule 68 (factor -> ID .)
    MINUSMINUS      reduce using rule 68 (factor -> ID .)
    PLUS            reduce using rule 68 (factor -> ID .)
    MINUS           reduce using rule 68 (factor -> ID .)
    MUL             reduce using rule 68 (factor -> ID .)
    DIV             reduce using rule 68 (factor -> ID .)
    REM             reduce using rule 68 (factor -> ID .)
    SEMICOLON       reduce using rule 68 (factor -> ID .)
    VAR             reduce using rule 68 (factor -> ID .)
    ID              reduce using rule 68 (factor -> ID .)
    IF              reduce using rule 68 (factor -> ID .)
    WHILE           reduce using rule 68 (factor -> ID .)
    FUNC            reduce using rule 68 (factor -> ID .)
    TRY             reduce using rule 68 (factor -> ID .)
    ZOUT            reduce using rule 68 (factor -> ID .)
    TUPLE           reduce using rule 68 (factor -> ID .)
    LIST            reduce using rule 68 (factor -> ID .)
    NUMBER          reduce using rule 68 (factor -> ID .)
    STRING          reduce using rule 68 (factor -> ID .)
    TRUE            reduce using rule 68 (factor -> ID .)
    FALSE           reduce using rule 68 (factor -> ID .)
    $end            reduce using rule 68 (factor -> ID .)
    END             reduce using rule 68 (factor -> ID .)
    RETURN          reduce using rule 68 (factor -> ID .)

  ! LPAREN          [ reduce using rule 68 (factor -> ID .) ]


state 74

    (19) assignment -> ID ASSIGN L .

    SEMICOLON       reduce using rule 19 (assignment -> ID ASSIGN L .)
    VAR             reduce using rule 19 (assignment -> ID ASSIGN L .)
    ID              reduce using rule 19 (assignment -> ID ASSIGN L .)
    IF              reduce using rule 19 (assignment -> ID ASSIGN L .)
    WHILE           reduce using rule 19 (assignment -> ID ASSIGN L .)
    FUNC            reduce using rule 19 (assignment -> ID ASSIGN L .)
    TRY             reduce using rule 19 (assignment -> ID ASSIGN L .)
    ZOUT            reduce using rule 19 (assignment -> ID ASSIGN L .)
    TUPLE           reduce using rule 19 (assignment -> ID ASSIGN L .)
    LIST            reduce using rule 19 (assignment -> ID ASSIGN L .)
    NUMBER          reduce using rule 19 (assignment -> ID ASSIGN L .)
    STRING          reduce using rule 19 (assignment -> ID ASSIGN L .)
    TRUE            reduce using rule 19 (assignment -> ID ASSIGN L .)
    FALSE           reduce using rule 19 (assignment -> ID ASSIGN L .)
    LPAREN          reduce using rule 19 (assignment -> ID ASSIGN L .)
    $end            reduce using rule 19 (assignment -> ID ASSIGN L .)
    END             reduce using rule 19 (assignment -> ID ASSIGN L .)
    RETURN          reduce using rule 19 (assignment -> ID ASSIGN L .)


state 75

    (17) L -> statement .

    SEMICOLON       reduce using rule 17 (L -> statement .)
    VAR             reduce using rule 17 (L -> statement .)
    ID              reduce using rule 17 (L -> statement .)
    IF              reduce using rule 17 (L -> statement .)
    WHILE           reduce using rule 17 (L -> statement .)
    FUNC            reduce using rule 17 (L -> statement .)
    TRY             reduce using rule 17 (L -> statement .)
    ZOUT            reduce using rule 17 (L -> statement .)
    TUPLE           reduce using rule 17 (L -> statement .)
    LIST            reduce using rule 17 (L -> statement .)
    NUMBER          reduce using rule 17 (L -> statement .)
    STRING          reduce using rule 17 (L -> statement .)
    TRUE            reduce using rule 17 (L -> statement .)
    FALSE           reduce using rule 17 (L -> statement .)
    LPAREN          reduce using rule 17 (L -> statement .)
    $end            reduce using rule 17 (L -> statement .)
    END             reduce using rule 17 (L -> statement .)
    RETURN          reduce using rule 17 (L -> statement .)


state 76

    (30) compound_type_access -> ID LSPAREN expression . RSPAREN
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    RSPAREN         shift and go to state 93
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    binary_operator                shift and go to state 36

state 77

    (40) if_stmnt -> IF LPAREN condition . RPAREN BEGIN statement_list END T

    RPAREN          shift and go to state 94


state 78

    (50) condition -> expression . comparison_operator expression
    (57) expression -> expression . binary_operator expression
    (51) comparison_operator -> . EQEQ
    (52) comparison_operator -> . NOTEQ
    (53) comparison_operator -> . LT
    (54) comparison_operator -> . GT
    (55) comparison_operator -> . LTEQ
    (56) comparison_operator -> . GTEQ
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    EQEQ            shift and go to state 96
    NOTEQ           shift and go to state 97
    LT              shift and go to state 98
    GT              shift and go to state 99
    LTEQ            shift and go to state 100
    GTEQ            shift and go to state 101
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    comparison_operator            shift and go to state 95
    binary_operator                shift and go to state 36

state 79

    (73) factor -> LPAREN expression RPAREN .

    PLUSPLUS        reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    MINUSMINUS      reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    MUL             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    REM             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    VAR             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    TRY             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    ZOUT            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    TUPLE           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    LIST            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    STRING          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    RSPAREN         reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    NOTEQ           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 73 (factor -> LPAREN expression RPAREN .)


state 80

    (45) while_stmt -> WHILE LPAREN condition . RPAREN BEGIN statement_list END

    RPAREN          shift and go to state 102


state 81

    (46) function_call -> FUNC ID LPAREN . parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (47) parameter_list -> . type ID parameter_list
    (48) parameter_list -> . COMMA parameter_list
    (49) parameter_list -> . empty
    (20) type -> . INT
    (21) type -> . BOOL
    (22) type -> . STR
    (79) empty -> .

    COMMA           shift and go to state 105
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    STR             shift and go to state 45
    RPAREN          reduce using rule 79 (empty -> .)

    parameter_list                 shift and go to state 103
    type                           shift and go to state 104
    empty                          shift and go to state 106

state 82

    (23) compound_types -> A ID ASSIGN . LPAREN data RPAREN

    LPAREN          shift and go to state 107


state 83

    (32) F -> CON LPAREN . factor RPAREN
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    factor                         shift and go to state 108

state 84

    (34) F -> ADD LPAREN . factor RPAREN
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    factor                         shift and go to state 109

state 85

    (38) F -> SUBSTR LPAREN . factor COMMA factor RPAREN
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    factor                         shift and go to state 110

state 86

    (74) try_except -> TRY COLON x . EXCEPT COLON x

    EXCEPT          shift and go to state 111


state 87

    (75) x -> BEGIN . statement_list END
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    END             reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 112
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 88

    (76) print -> ZOUT LPAREN y . RPAREN

    RPAREN          shift and go to state 113


state 89

    (77) y -> expression .
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    RPAREN          reduce using rule 77 (y -> expression .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    binary_operator                shift and go to state 36

state 90

    (78) y -> compound_type_access .

    RPAREN          reduce using rule 78 (y -> compound_type_access .)


state 91

    (30) compound_type_access -> ID . LSPAREN expression RSPAREN
    (31) Z -> ID . DOT
    (68) factor -> ID .

    LSPAREN         shift and go to state 47
    DOT             shift and go to state 48
    PLUSPLUS        reduce using rule 68 (factor -> ID .)
    MINUSMINUS      reduce using rule 68 (factor -> ID .)
    PLUS            reduce using rule 68 (factor -> ID .)
    MINUS           reduce using rule 68 (factor -> ID .)
    MUL             reduce using rule 68 (factor -> ID .)
    DIV             reduce using rule 68 (factor -> ID .)
    REM             reduce using rule 68 (factor -> ID .)
    RPAREN          reduce using rule 68 (factor -> ID .)


state 92

    (18) L -> ID LPAREN . data RPAREN
    (26) data -> . expression data
    (27) data -> . COMMA data
    (28) data -> . empty
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (79) empty -> .
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 79 (empty -> .)
    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    data                           shift and go to state 114
    expression                     shift and go to state 115
    empty                          shift and go to state 117
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 93

    (30) compound_type_access -> ID LSPAREN expression RSPAREN .

    SEMICOLON       reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    VAR             reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    ID              reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    IF              reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    WHILE           reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    FUNC            reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    TRY             reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    ZOUT            reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    TUPLE           reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    LIST            reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    NUMBER          reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    STRING          reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    TRUE            reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    FALSE           reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    LPAREN          reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    $end            reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    END             reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    RETURN          reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    RPAREN          reduce using rule 30 (compound_type_access -> ID LSPAREN expression RSPAREN .)


state 94

    (40) if_stmnt -> IF LPAREN condition RPAREN . BEGIN statement_list END T

    BEGIN           shift and go to state 118


state 95

    (50) condition -> expression comparison_operator . expression
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    expression                     shift and go to state 119
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 96

    (51) comparison_operator -> EQEQ .

    ID              reduce using rule 51 (comparison_operator -> EQEQ .)
    NUMBER          reduce using rule 51 (comparison_operator -> EQEQ .)
    STRING          reduce using rule 51 (comparison_operator -> EQEQ .)
    TRUE            reduce using rule 51 (comparison_operator -> EQEQ .)
    FALSE           reduce using rule 51 (comparison_operator -> EQEQ .)
    LPAREN          reduce using rule 51 (comparison_operator -> EQEQ .)


state 97

    (52) comparison_operator -> NOTEQ .

    ID              reduce using rule 52 (comparison_operator -> NOTEQ .)
    NUMBER          reduce using rule 52 (comparison_operator -> NOTEQ .)
    STRING          reduce using rule 52 (comparison_operator -> NOTEQ .)
    TRUE            reduce using rule 52 (comparison_operator -> NOTEQ .)
    FALSE           reduce using rule 52 (comparison_operator -> NOTEQ .)
    LPAREN          reduce using rule 52 (comparison_operator -> NOTEQ .)


state 98

    (53) comparison_operator -> LT .

    ID              reduce using rule 53 (comparison_operator -> LT .)
    NUMBER          reduce using rule 53 (comparison_operator -> LT .)
    STRING          reduce using rule 53 (comparison_operator -> LT .)
    TRUE            reduce using rule 53 (comparison_operator -> LT .)
    FALSE           reduce using rule 53 (comparison_operator -> LT .)
    LPAREN          reduce using rule 53 (comparison_operator -> LT .)


state 99

    (54) comparison_operator -> GT .

    ID              reduce using rule 54 (comparison_operator -> GT .)
    NUMBER          reduce using rule 54 (comparison_operator -> GT .)
    STRING          reduce using rule 54 (comparison_operator -> GT .)
    TRUE            reduce using rule 54 (comparison_operator -> GT .)
    FALSE           reduce using rule 54 (comparison_operator -> GT .)
    LPAREN          reduce using rule 54 (comparison_operator -> GT .)


state 100

    (55) comparison_operator -> LTEQ .

    ID              reduce using rule 55 (comparison_operator -> LTEQ .)
    NUMBER          reduce using rule 55 (comparison_operator -> LTEQ .)
    STRING          reduce using rule 55 (comparison_operator -> LTEQ .)
    TRUE            reduce using rule 55 (comparison_operator -> LTEQ .)
    FALSE           reduce using rule 55 (comparison_operator -> LTEQ .)
    LPAREN          reduce using rule 55 (comparison_operator -> LTEQ .)


state 101

    (56) comparison_operator -> GTEQ .

    ID              reduce using rule 56 (comparison_operator -> GTEQ .)
    NUMBER          reduce using rule 56 (comparison_operator -> GTEQ .)
    STRING          reduce using rule 56 (comparison_operator -> GTEQ .)
    TRUE            reduce using rule 56 (comparison_operator -> GTEQ .)
    FALSE           reduce using rule 56 (comparison_operator -> GTEQ .)
    LPAREN          reduce using rule 56 (comparison_operator -> GTEQ .)


state 102

    (45) while_stmt -> WHILE LPAREN condition RPAREN . BEGIN statement_list END

    BEGIN           shift and go to state 120


state 103

    (46) function_call -> FUNC ID LPAREN parameter_list . RPAREN BEGIN statement_list RETURN data SEMICOLON END

    RPAREN          shift and go to state 121


state 104

    (47) parameter_list -> type . ID parameter_list

    ID              shift and go to state 122


state 105

    (48) parameter_list -> COMMA . parameter_list
    (47) parameter_list -> . type ID parameter_list
    (48) parameter_list -> . COMMA parameter_list
    (49) parameter_list -> . empty
    (20) type -> . INT
    (21) type -> . BOOL
    (22) type -> . STR
    (79) empty -> .

    COMMA           shift and go to state 105
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    STR             shift and go to state 45
    RPAREN          reduce using rule 79 (empty -> .)

    parameter_list                 shift and go to state 123
    type                           shift and go to state 104
    empty                          shift and go to state 106

state 106

    (49) parameter_list -> empty .

    RPAREN          reduce using rule 49 (parameter_list -> empty .)


state 107

    (23) compound_types -> A ID ASSIGN LPAREN . data RPAREN
    (26) data -> . expression data
    (27) data -> . COMMA data
    (28) data -> . empty
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (79) empty -> .
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 79 (empty -> .)
    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    data                           shift and go to state 124
    expression                     shift and go to state 115
    empty                          shift and go to state 117
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 108

    (32) F -> CON LPAREN factor . RPAREN

    RPAREN          shift and go to state 125


state 109

    (34) F -> ADD LPAREN factor . RPAREN

    RPAREN          shift and go to state 126


state 110

    (38) F -> SUBSTR LPAREN factor . COMMA factor RPAREN

    COMMA           shift and go to state 127


state 111

    (74) try_except -> TRY COLON x EXCEPT . COLON x

    COLON           shift and go to state 128


state 112

    (75) x -> BEGIN statement_list . END

    END             shift and go to state 129


state 113

    (76) print -> ZOUT LPAREN y RPAREN .

    SEMICOLON       reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    VAR             reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    ID              reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    IF              reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    WHILE           reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    FUNC            reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    TRY             reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    ZOUT            reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    TUPLE           reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    LIST            reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    NUMBER          reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    STRING          reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    TRUE            reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    FALSE           reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    LPAREN          reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    $end            reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    END             reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)
    RETURN          reduce using rule 76 (print -> ZOUT LPAREN y RPAREN .)


state 114

    (18) L -> ID LPAREN data . RPAREN

    RPAREN          shift and go to state 130


state 115

    (26) data -> expression . data
    (57) expression -> expression . binary_operator expression
    (26) data -> . expression data
    (27) data -> . COMMA data
    (28) data -> . empty
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (79) empty -> .
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 116
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41
    RPAREN          reduce using rule 79 (empty -> .)
    SEMICOLON       reduce using rule 79 (empty -> .)
    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    expression                     shift and go to state 115
    data                           shift and go to state 131
    binary_operator                shift and go to state 36
    empty                          shift and go to state 117
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 116

    (27) data -> COMMA . data
    (26) data -> . expression data
    (27) data -> . COMMA data
    (28) data -> . empty
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (79) empty -> .
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 79 (empty -> .)
    SEMICOLON       reduce using rule 79 (empty -> .)
    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    data                           shift and go to state 132
    expression                     shift and go to state 115
    empty                          shift and go to state 117
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 117

    (28) data -> empty .

    RPAREN          reduce using rule 28 (data -> empty .)
    SEMICOLON       reduce using rule 28 (data -> empty .)


state 118

    (40) if_stmnt -> IF LPAREN condition RPAREN BEGIN . statement_list END T
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    END             reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 133
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 119

    (50) condition -> expression comparison_operator expression .
    (57) expression -> expression . binary_operator expression
    (59) binary_operator -> . PLUS
    (60) binary_operator -> . MINUS
    (61) binary_operator -> . MUL
    (62) binary_operator -> . DIV
    (63) binary_operator -> . REM

    RPAREN          reduce using rule 50 (condition -> expression comparison_operator expression .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    REM             shift and go to state 41

    binary_operator                shift and go to state 36

state 120

    (45) while_stmt -> WHILE LPAREN condition RPAREN BEGIN . statement_list END
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    END             reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 134
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 121

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN . BEGIN statement_list RETURN data SEMICOLON END

    BEGIN           shift and go to state 135


state 122

    (47) parameter_list -> type ID . parameter_list
    (47) parameter_list -> . type ID parameter_list
    (48) parameter_list -> . COMMA parameter_list
    (49) parameter_list -> . empty
    (20) type -> . INT
    (21) type -> . BOOL
    (22) type -> . STR
    (79) empty -> .

    COMMA           shift and go to state 105
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    STR             shift and go to state 45
    RPAREN          reduce using rule 79 (empty -> .)

    type                           shift and go to state 104
    parameter_list                 shift and go to state 136
    empty                          shift and go to state 106

state 123

    (48) parameter_list -> COMMA parameter_list .

    RPAREN          reduce using rule 48 (parameter_list -> COMMA parameter_list .)


state 124

    (23) compound_types -> A ID ASSIGN LPAREN data . RPAREN

    RPAREN          shift and go to state 137


state 125

    (32) F -> CON LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    VAR             reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    ID              reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    IF              reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    WHILE           reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    FUNC            reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    TRY             reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    ZOUT            reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    TUPLE           reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    LIST            reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    NUMBER          reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    STRING          reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    TRUE            reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    FALSE           reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    LPAREN          reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    $end            reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    END             reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    RETURN          reduce using rule 32 (F -> CON LPAREN factor RPAREN .)
    RPAREN          reduce using rule 32 (F -> CON LPAREN factor RPAREN .)


state 126

    (34) F -> ADD LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    VAR             reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    ID              reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    IF              reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    WHILE           reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    FUNC            reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    TRY             reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    ZOUT            reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    TUPLE           reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    LIST            reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    NUMBER          reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    STRING          reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    TRUE            reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    FALSE           reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    LPAREN          reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    $end            reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    END             reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    RETURN          reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)
    RPAREN          reduce using rule 34 (F -> ADD LPAREN factor RPAREN .)


state 127

    (38) F -> SUBSTR LPAREN factor COMMA . factor RPAREN
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    factor                         shift and go to state 138

state 128

    (74) try_except -> TRY COLON x EXCEPT COLON . x
    (75) x -> . BEGIN statement_list END

    BEGIN           shift and go to state 87

    x                              shift and go to state 139

state 129

    (75) x -> BEGIN statement_list END .

    EXCEPT          reduce using rule 75 (x -> BEGIN statement_list END .)
    SEMICOLON       reduce using rule 75 (x -> BEGIN statement_list END .)
    VAR             reduce using rule 75 (x -> BEGIN statement_list END .)
    ID              reduce using rule 75 (x -> BEGIN statement_list END .)
    IF              reduce using rule 75 (x -> BEGIN statement_list END .)
    WHILE           reduce using rule 75 (x -> BEGIN statement_list END .)
    FUNC            reduce using rule 75 (x -> BEGIN statement_list END .)
    TRY             reduce using rule 75 (x -> BEGIN statement_list END .)
    ZOUT            reduce using rule 75 (x -> BEGIN statement_list END .)
    TUPLE           reduce using rule 75 (x -> BEGIN statement_list END .)
    LIST            reduce using rule 75 (x -> BEGIN statement_list END .)
    NUMBER          reduce using rule 75 (x -> BEGIN statement_list END .)
    STRING          reduce using rule 75 (x -> BEGIN statement_list END .)
    TRUE            reduce using rule 75 (x -> BEGIN statement_list END .)
    FALSE           reduce using rule 75 (x -> BEGIN statement_list END .)
    LPAREN          reduce using rule 75 (x -> BEGIN statement_list END .)
    $end            reduce using rule 75 (x -> BEGIN statement_list END .)
    END             reduce using rule 75 (x -> BEGIN statement_list END .)
    RETURN          reduce using rule 75 (x -> BEGIN statement_list END .)


state 130

    (18) L -> ID LPAREN data RPAREN .

    SEMICOLON       reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    VAR             reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    ID              reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    IF              reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    WHILE           reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    FUNC            reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    TRY             reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    ZOUT            reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    TUPLE           reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    LIST            reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    NUMBER          reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    STRING          reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    TRUE            reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    FALSE           reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    LPAREN          reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    $end            reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    END             reduce using rule 18 (L -> ID LPAREN data RPAREN .)
    RETURN          reduce using rule 18 (L -> ID LPAREN data RPAREN .)


state 131

    (26) data -> expression data .

    RPAREN          reduce using rule 26 (data -> expression data .)
    SEMICOLON       reduce using rule 26 (data -> expression data .)


state 132

    (27) data -> COMMA data .

    RPAREN          reduce using rule 27 (data -> COMMA data .)
    SEMICOLON       reduce using rule 27 (data -> COMMA data .)


state 133

    (40) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list . END T

    END             shift and go to state 140


state 134

    (45) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list . END

    END             shift and go to state 141


state 135

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN . statement_list RETURN data SEMICOLON END
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    RETURN          reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 142
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 136

    (47) parameter_list -> type ID parameter_list .

    RPAREN          reduce using rule 47 (parameter_list -> type ID parameter_list .)


state 137

    (23) compound_types -> A ID ASSIGN LPAREN data RPAREN .

    SEMICOLON       reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    VAR             reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    ID              reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    IF              reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    WHILE           reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    FUNC            reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    TRY             reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    ZOUT            reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    TUPLE           reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    LIST            reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    NUMBER          reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    STRING          reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    TRUE            reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    FALSE           reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    LPAREN          reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    $end            reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    END             reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)
    RETURN          reduce using rule 23 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)


state 138

    (38) F -> SUBSTR LPAREN factor COMMA factor . RPAREN

    RPAREN          shift and go to state 143


state 139

    (74) try_except -> TRY COLON x EXCEPT COLON x .

    SEMICOLON       reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    VAR             reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    ID              reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    IF              reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    WHILE           reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    FUNC            reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    TRY             reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    ZOUT            reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    TUPLE           reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    LIST            reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    NUMBER          reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    STRING          reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    TRUE            reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    FALSE           reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    LPAREN          reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    $end            reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    END             reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)
    RETURN          reduce using rule 74 (try_except -> TRY COLON x EXCEPT COLON x .)


state 140

    (40) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END . T
    (41) T -> . ELIF LPAREN condition RPAREN BEGIN statement_list END K
    (42) T -> . empty
    (79) empty -> .

    ELIF            shift and go to state 145
    SEMICOLON       reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)
    ID              reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    FUNC            reduce using rule 79 (empty -> .)
    TRY             reduce using rule 79 (empty -> .)
    ZOUT            reduce using rule 79 (empty -> .)
    TUPLE           reduce using rule 79 (empty -> .)
    LIST            reduce using rule 79 (empty -> .)
    NUMBER          reduce using rule 79 (empty -> .)
    STRING          reduce using rule 79 (empty -> .)
    TRUE            reduce using rule 79 (empty -> .)
    FALSE           reduce using rule 79 (empty -> .)
    LPAREN          reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)

    T                              shift and go to state 144
    empty                          shift and go to state 146

state 141

    (45) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .

    SEMICOLON       reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    VAR             reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    ID              reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    IF              reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    WHILE           reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    FUNC            reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    TRY             reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    ZOUT            reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    TUPLE           reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    LIST            reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    NUMBER          reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    STRING          reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    TRUE            reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    FALSE           reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    LPAREN          reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    $end            reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    END             reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)
    RETURN          reduce using rule 45 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)


state 142

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list . RETURN data SEMICOLON END

    RETURN          shift and go to state 147


state 143

    (38) F -> SUBSTR LPAREN factor COMMA factor RPAREN .

    SEMICOLON       reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    VAR             reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    ID              reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    IF              reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    WHILE           reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    FUNC            reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    TRY             reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    ZOUT            reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    TUPLE           reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    LIST            reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    NUMBER          reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    STRING          reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    TRUE            reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    FALSE           reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    LPAREN          reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    $end            reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    END             reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    RETURN          reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    RPAREN          reduce using rule 38 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)


state 144

    (40) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .

    SEMICOLON       reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    VAR             reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    ID              reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    IF              reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    WHILE           reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    FUNC            reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    TRY             reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    ZOUT            reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    TUPLE           reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    LIST            reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    NUMBER          reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    STRING          reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    TRUE            reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    FALSE           reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    LPAREN          reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    $end            reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    END             reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)
    RETURN          reduce using rule 40 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)


state 145

    (41) T -> ELIF . LPAREN condition RPAREN BEGIN statement_list END K

    LPAREN          shift and go to state 148


state 146

    (42) T -> empty .

    SEMICOLON       reduce using rule 42 (T -> empty .)
    VAR             reduce using rule 42 (T -> empty .)
    ID              reduce using rule 42 (T -> empty .)
    IF              reduce using rule 42 (T -> empty .)
    WHILE           reduce using rule 42 (T -> empty .)
    FUNC            reduce using rule 42 (T -> empty .)
    TRY             reduce using rule 42 (T -> empty .)
    ZOUT            reduce using rule 42 (T -> empty .)
    TUPLE           reduce using rule 42 (T -> empty .)
    LIST            reduce using rule 42 (T -> empty .)
    NUMBER          reduce using rule 42 (T -> empty .)
    STRING          reduce using rule 42 (T -> empty .)
    TRUE            reduce using rule 42 (T -> empty .)
    FALSE           reduce using rule 42 (T -> empty .)
    LPAREN          reduce using rule 42 (T -> empty .)
    $end            reduce using rule 42 (T -> empty .)
    END             reduce using rule 42 (T -> empty .)
    RETURN          reduce using rule 42 (T -> empty .)


state 147

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN . data SEMICOLON END
    (26) data -> . expression data
    (27) data -> . COMMA data
    (28) data -> . empty
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (79) empty -> .
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 116
    SEMICOLON       reduce using rule 79 (empty -> .)
    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    data                           shift and go to state 149
    expression                     shift and go to state 115
    empty                          shift and go to state 117
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 148

    (41) T -> ELIF LPAREN . condition RPAREN BEGIN statement_list END K
    (50) condition -> . expression comparison_operator expression
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (64) term -> . factor
    (65) term -> . term unary_operator
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 51
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    condition                      shift and go to state 150
    expression                     shift and go to state 78
    term                           shift and go to state 21
    factor                         shift and go to state 26

state 149

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data . SEMICOLON END

    SEMICOLON       shift and go to state 151


state 150

    (41) T -> ELIF LPAREN condition . RPAREN BEGIN statement_list END K

    RPAREN          shift and go to state 152


state 151

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON . END

    END             shift and go to state 153


state 152

    (41) T -> ELIF LPAREN condition RPAREN . BEGIN statement_list END K

    BEGIN           shift and go to state 154


state 153

    (46) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .

    SEMICOLON       reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    VAR             reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    ID              reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    IF              reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    WHILE           reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    FUNC            reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    TRY             reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    ZOUT            reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    TUPLE           reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    LIST            reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    NUMBER          reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    STRING          reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    TRUE            reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    FALSE           reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    LPAREN          reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    $end            reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    END             reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)
    RETURN          reduce using rule 46 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)


state 154

    (41) T -> ELIF LPAREN condition RPAREN BEGIN . statement_list END K
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    END             reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 155
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 155

    (41) T -> ELIF LPAREN condition RPAREN BEGIN statement_list . END K

    END             shift and go to state 156


state 156

    (41) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END . K
    (43) K -> . ELSE BEGIN statement_list END
    (44) K -> . empty
    (79) empty -> .

    ELSE            shift and go to state 158
    SEMICOLON       reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)
    ID              reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    WHILE           reduce using rule 79 (empty -> .)
    FUNC            reduce using rule 79 (empty -> .)
    TRY             reduce using rule 79 (empty -> .)
    ZOUT            reduce using rule 79 (empty -> .)
    TUPLE           reduce using rule 79 (empty -> .)
    LIST            reduce using rule 79 (empty -> .)
    NUMBER          reduce using rule 79 (empty -> .)
    STRING          reduce using rule 79 (empty -> .)
    TRUE            reduce using rule 79 (empty -> .)
    FALSE           reduce using rule 79 (empty -> .)
    LPAREN          reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    END             reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)

    K                              shift and go to state 157
    empty                          shift and go to state 159

state 157

    (41) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .

    SEMICOLON       reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    VAR             reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    ID              reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    IF              reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    WHILE           reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    FUNC            reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    TRY             reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    ZOUT            reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    TUPLE           reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    LIST            reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    NUMBER          reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    STRING          reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    TRUE            reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    FALSE           reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    LPAREN          reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    $end            reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    END             reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)
    RETURN          reduce using rule 41 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)


state 158

    (43) K -> ELSE . BEGIN statement_list END

    BEGIN           shift and go to state 160


state 159

    (44) K -> empty .

    SEMICOLON       reduce using rule 44 (K -> empty .)
    VAR             reduce using rule 44 (K -> empty .)
    ID              reduce using rule 44 (K -> empty .)
    IF              reduce using rule 44 (K -> empty .)
    WHILE           reduce using rule 44 (K -> empty .)
    FUNC            reduce using rule 44 (K -> empty .)
    TRY             reduce using rule 44 (K -> empty .)
    ZOUT            reduce using rule 44 (K -> empty .)
    TUPLE           reduce using rule 44 (K -> empty .)
    LIST            reduce using rule 44 (K -> empty .)
    NUMBER          reduce using rule 44 (K -> empty .)
    STRING          reduce using rule 44 (K -> empty .)
    TRUE            reduce using rule 44 (K -> empty .)
    FALSE           reduce using rule 44 (K -> empty .)
    LPAREN          reduce using rule 44 (K -> empty .)
    $end            reduce using rule 44 (K -> empty .)
    END             reduce using rule 44 (K -> empty .)
    RETURN          reduce using rule 44 (K -> empty .)


state 160

    (43) K -> ELSE BEGIN . statement_list END
    (2) statement_list -> . statement KA statement_list
    (3) statement_list -> . empty
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . if_stmnt
    (9) statement -> . while_stmt
    (10) statement -> . function_call
    (11) statement -> . expression
    (12) statement -> . compound_types
    (13) statement -> . compound_type_access
    (14) statement -> . try_except
    (15) statement -> . print
    (79) empty -> .
    (16) declaration -> . VAR type assignment
    (19) assignment -> . ID ASSIGN L
    (40) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (45) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (46) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (57) expression -> . expression binary_operator expression
    (58) expression -> . term
    (23) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (29) compound_type_access -> . Z F
    (30) compound_type_access -> . ID LSPAREN expression RSPAREN
    (74) try_except -> . TRY COLON x EXCEPT COLON x
    (76) print -> . ZOUT LPAREN y RPAREN
    (64) term -> . factor
    (65) term -> . term unary_operator
    (24) A -> . TUPLE
    (25) A -> . LIST
    (31) Z -> . ID DOT
    (68) factor -> . ID
    (69) factor -> . NUMBER
    (70) factor -> . STRING
    (71) factor -> . TRUE
    (72) factor -> . FALSE
    (73) factor -> . LPAREN expression RPAREN

    END             reduce using rule 79 (empty -> .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 19
    FUNC            shift and go to state 20
    TRY             shift and go to state 24
    ZOUT            shift and go to state 25
    TUPLE           shift and go to state 27
    LIST            shift and go to state 28
    NUMBER          shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LPAREN          shift and go to state 18

    statement_list                 shift and go to state 161
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    term                           shift and go to state 21
    A                              shift and go to state 22
    Z                              shift and go to state 23
    factor                         shift and go to state 26

state 161

    (43) K -> ELSE BEGIN statement_list . END

    END             shift and go to state 162


state 162

    (43) K -> ELSE BEGIN statement_list END .

    SEMICOLON       reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    VAR             reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    ID              reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    IF              reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    WHILE           reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    FUNC            reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    TRY             reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    ZOUT            reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    TUPLE           reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    LIST            reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    NUMBER          reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    STRING          reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    TRUE            reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    FALSE           reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    LPAREN          reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    $end            reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    END             reduce using rule 43 (K -> ELSE BEGIN statement_list END .)
    RETURN          reduce using rule 43 (K -> ELSE BEGIN statement_list END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MUL in state 70 resolved as shift
WARNING: shift/reduce conflict for DIV in state 70 resolved as shift
WARNING: shift/reduce conflict for REM in state 70 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 73 resolved as shift
