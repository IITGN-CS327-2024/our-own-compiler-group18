Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> statement_list
Rule 2     statement_list -> statement_list statement SEMICOLON
Rule 3     statement_list -> empty
Rule 4     statement -> declaration
Rule 5     statement -> assignment
Rule 6     statement -> if_stmnt
Rule 7     statement -> while_stmt
Rule 8     statement -> function_call
Rule 9     statement -> expression
Rule 10    statement -> compound_types
Rule 11    statement -> compound_type_access
Rule 12    statement -> try_except
Rule 13    statement -> print
Rule 14    declaration -> VAR type assignment
Rule 15    assignment -> ID ASSIGN L
Rule 16    L -> statement
Rule 17    L -> ID LPAREN data RPAREN
Rule 18    type -> INT
Rule 19    type -> BOOL
Rule 20    type -> STR
Rule 21    compound_types -> A ID ASSIGN LPAREN data RPAREN
Rule 22    A -> TUPLE
Rule 23    A -> LIST
Rule 24    data -> expression data
Rule 25    data -> COMMA data
Rule 26    data -> empty
Rule 27    compound_type_access -> ID DOT F
Rule 28    compound_type_access -> ID LSPAREN expression RSPAREN
Rule 29    F -> CON LPAREN factor RPAREN
Rule 30    F -> FRONT
Rule 31    F -> ADD LPAREN factor RPAREN
Rule 32    F -> REAR
Rule 33    F -> SIZE
Rule 34    F -> DELETE
Rule 35    F -> SUBSTR LPAREN factor COMMA factor RPAREN
Rule 36    F -> empty
Rule 37    if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T
Rule 38    T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K
Rule 39    T -> empty
Rule 40    K -> ELSE BEGIN statement_list END
Rule 41    K -> empty
Rule 42    while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END
Rule 43    function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
Rule 44    parameter_list -> type ID optional_parameter_list
Rule 45    parameter_list -> empty
Rule 46    optional_parameter_list -> COMMA type ID optional_parameter_list
Rule 47    optional_parameter_list -> empty
Rule 48    condition -> expression comparison_operator expression
Rule 49    comparison_operator -> EQEQ
Rule 50    comparison_operator -> NOTEQ
Rule 51    comparison_operator -> LT
Rule 52    comparison_operator -> GT
Rule 53    comparison_operator -> LTEQ
Rule 54    comparison_operator -> GTEQ
Rule 55    expression -> expression binary_operator expression
Rule 56    expression -> expression unary_operator
Rule 57    expression -> factor
Rule 58    binary_operator -> MINUS
Rule 59    binary_operator -> MUL
Rule 60    binary_operator -> PLUS
Rule 61    binary_operator -> DIV
Rule 62    binary_operator -> REM
Rule 63    unary_operator -> PLUSPLUS
Rule 64    unary_operator -> MINUSMINUS
Rule 65    factor -> ID
Rule 66    factor -> NUMBER
Rule 67    factor -> STRING
Rule 68    factor -> TRUE
Rule 69    factor -> FALSE
Rule 70    factor -> LPAREN expression RPAREN
Rule 71    try_except -> BEGIN TRY statement_list EXCEPT statement_list END
Rule 72    print -> ZOUT LPAREN y RPAREN
Rule 73    y -> expression
Rule 74    y -> compound_type_access
Rule 75    empty -> <empty>

Terminals, with rules where they appear

ADD                  : 31
ASSIGN               : 15 21
BEGIN                : 37 38 40 42 43 71
BOOL                 : 19
COMMA                : 25 35 46
CON                  : 29
DELETE               : 34
DIV                  : 61
DOT                  : 27
ELIF                 : 38
ELSE                 : 40
END                  : 37 38 40 42 43 71
EQEQ                 : 49
EXCEPT               : 71
FALSE                : 69
FRONT                : 30
FUNC                 : 43
GT                   : 52
GTEQ                 : 54
ID                   : 15 17 21 27 28 43 44 46 65
IF                   : 37
INT                  : 18
LIST                 : 23
LPAREN               : 17 21 29 31 35 37 38 42 43 70 72
LSPAREN              : 28
LT                   : 51
LTEQ                 : 53
MINUS                : 58
MINUSMINUS           : 64
MUL                  : 59
NOTEQ                : 50
NUMBER               : 66
PLUS                 : 60
PLUSPLUS             : 63
REAR                 : 32
REM                  : 62
RETURN               : 43
RPAREN               : 17 21 29 31 35 37 38 42 43 70 72
RSPAREN              : 28
SEMICOLON            : 2 43
SIZE                 : 33
STR                  : 20
STRING               : 67
SUBSTR               : 35
TRUE                 : 68
TRY                  : 71
TUPLE                : 22
VAR                  : 14
WHILE                : 42
ZOUT                 : 72
error                : 

Nonterminals, with rules where they appear

A                    : 21
F                    : 27
K                    : 38
L                    : 15
T                    : 37
assignment           : 5 14
binary_operator      : 55
comparison_operator  : 48
compound_type_access : 11 74
compound_types       : 10
condition            : 37 38 42
data                 : 17 21 24 25 43
declaration          : 4
empty                : 3 26 36 39 41 45 47
expression           : 9 24 28 48 48 55 55 56 70 73
factor               : 29 31 35 35 57
function_call        : 8
if_stmnt             : 6
optional_parameter_list : 44 46
parameter_list       : 43
print                : 13
start                : 0
statement            : 2 16
statement_list       : 1 2 37 38 40 42 43 71 71
try_except           : 12
type                 : 14 44 46
unary_operator       : 56
while_stmt           : 7
y                    : 72

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . statement_list
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)
    $end            reduce using rule 75 (empty -> .)

    start                          shift and go to state 1
    statement_list                 shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start .



state 2

    (1) start -> statement_list .
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    $end            reduce using rule 1 (start -> statement_list .)
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 3

    (3) statement_list -> empty .

    VAR             reduce using rule 3 (statement_list -> empty .)
    ID              reduce using rule 3 (statement_list -> empty .)
    IF              reduce using rule 3 (statement_list -> empty .)
    WHILE           reduce using rule 3 (statement_list -> empty .)
    FUNC            reduce using rule 3 (statement_list -> empty .)
    BEGIN           reduce using rule 3 (statement_list -> empty .)
    ZOUT            reduce using rule 3 (statement_list -> empty .)
    NUMBER          reduce using rule 3 (statement_list -> empty .)
    STRING          reduce using rule 3 (statement_list -> empty .)
    TRUE            reduce using rule 3 (statement_list -> empty .)
    FALSE           reduce using rule 3 (statement_list -> empty .)
    LPAREN          reduce using rule 3 (statement_list -> empty .)
    TUPLE           reduce using rule 3 (statement_list -> empty .)
    LIST            reduce using rule 3 (statement_list -> empty .)
    $end            reduce using rule 3 (statement_list -> empty .)
    EXCEPT          reduce using rule 3 (statement_list -> empty .)
    END             reduce using rule 3 (statement_list -> empty .)
    RETURN          reduce using rule 3 (statement_list -> empty .)


state 4

    (2) statement_list -> statement_list statement . SEMICOLON

    SEMICOLON       shift and go to state 31


state 5

    (4) statement -> declaration .

    SEMICOLON       reduce using rule 4 (statement -> declaration .)


state 6

    (5) statement -> assignment .

    SEMICOLON       reduce using rule 5 (statement -> assignment .)


state 7

    (6) statement -> if_stmnt .

    SEMICOLON       reduce using rule 6 (statement -> if_stmnt .)


state 8

    (7) statement -> while_stmt .

    SEMICOLON       reduce using rule 7 (statement -> while_stmt .)


state 9

    (8) statement -> function_call .

    SEMICOLON       reduce using rule 8 (statement -> function_call .)


state 10

    (9) statement -> expression .
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    SEMICOLON       reduce using rule 9 (statement -> expression .)
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 11

    (10) statement -> compound_types .

    SEMICOLON       reduce using rule 10 (statement -> compound_types .)


state 12

    (11) statement -> compound_type_access .

    SEMICOLON       reduce using rule 11 (statement -> compound_type_access .)


state 13

    (12) statement -> try_except .

    SEMICOLON       reduce using rule 12 (statement -> try_except .)


state 14

    (13) statement -> print .

    SEMICOLON       reduce using rule 13 (statement -> print .)


state 15

    (14) declaration -> VAR . type assignment
    (18) type -> . INT
    (19) type -> . BOOL
    (20) type -> . STR

    INT             shift and go to state 42
    BOOL            shift and go to state 43
    STR             shift and go to state 44

    type                           shift and go to state 41

state 16

    (15) assignment -> ID . ASSIGN L
    (27) compound_type_access -> ID . DOT F
    (28) compound_type_access -> ID . LSPAREN expression RSPAREN
    (65) factor -> ID .

    ASSIGN          shift and go to state 45
    DOT             shift and go to state 46
    LSPAREN         shift and go to state 47
    MINUS           reduce using rule 65 (factor -> ID .)
    MUL             reduce using rule 65 (factor -> ID .)
    PLUS            reduce using rule 65 (factor -> ID .)
    DIV             reduce using rule 65 (factor -> ID .)
    REM             reduce using rule 65 (factor -> ID .)
    PLUSPLUS        reduce using rule 65 (factor -> ID .)
    MINUSMINUS      reduce using rule 65 (factor -> ID .)
    SEMICOLON       reduce using rule 65 (factor -> ID .)


state 17

    (37) if_stmnt -> IF . LPAREN condition RPAREN BEGIN statement_list END T

    LPAREN          shift and go to state 48


state 18

    (70) factor -> LPAREN . expression RPAREN
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    expression                     shift and go to state 49
    factor                         shift and go to state 22

state 19

    (71) try_except -> BEGIN . TRY statement_list EXCEPT statement_list END

    TRY             shift and go to state 51


state 20

    (42) while_stmt -> WHILE . LPAREN condition RPAREN BEGIN statement_list END

    LPAREN          shift and go to state 52


state 21

    (43) function_call -> FUNC . ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END

    ID              shift and go to state 53


state 22

    (57) expression -> factor .

    MINUS           reduce using rule 57 (expression -> factor .)
    MUL             reduce using rule 57 (expression -> factor .)
    PLUS            reduce using rule 57 (expression -> factor .)
    DIV             reduce using rule 57 (expression -> factor .)
    REM             reduce using rule 57 (expression -> factor .)
    PLUSPLUS        reduce using rule 57 (expression -> factor .)
    MINUSMINUS      reduce using rule 57 (expression -> factor .)
    SEMICOLON       reduce using rule 57 (expression -> factor .)
    RPAREN          reduce using rule 57 (expression -> factor .)
    RSPAREN         reduce using rule 57 (expression -> factor .)
    EQEQ            reduce using rule 57 (expression -> factor .)
    NOTEQ           reduce using rule 57 (expression -> factor .)
    LT              reduce using rule 57 (expression -> factor .)
    GT              reduce using rule 57 (expression -> factor .)
    LTEQ            reduce using rule 57 (expression -> factor .)
    GTEQ            reduce using rule 57 (expression -> factor .)
    COMMA           reduce using rule 57 (expression -> factor .)
    ID              reduce using rule 57 (expression -> factor .)
    NUMBER          reduce using rule 57 (expression -> factor .)
    STRING          reduce using rule 57 (expression -> factor .)
    TRUE            reduce using rule 57 (expression -> factor .)
    FALSE           reduce using rule 57 (expression -> factor .)
    LPAREN          reduce using rule 57 (expression -> factor .)


state 23

    (21) compound_types -> A . ID ASSIGN LPAREN data RPAREN

    ID              shift and go to state 54


state 24

    (72) print -> ZOUT . LPAREN y RPAREN

    LPAREN          shift and go to state 55


state 25

    (66) factor -> NUMBER .

    MINUS           reduce using rule 66 (factor -> NUMBER .)
    MUL             reduce using rule 66 (factor -> NUMBER .)
    PLUS            reduce using rule 66 (factor -> NUMBER .)
    DIV             reduce using rule 66 (factor -> NUMBER .)
    REM             reduce using rule 66 (factor -> NUMBER .)
    PLUSPLUS        reduce using rule 66 (factor -> NUMBER .)
    MINUSMINUS      reduce using rule 66 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 66 (factor -> NUMBER .)
    RPAREN          reduce using rule 66 (factor -> NUMBER .)
    RSPAREN         reduce using rule 66 (factor -> NUMBER .)
    EQEQ            reduce using rule 66 (factor -> NUMBER .)
    NOTEQ           reduce using rule 66 (factor -> NUMBER .)
    LT              reduce using rule 66 (factor -> NUMBER .)
    GT              reduce using rule 66 (factor -> NUMBER .)
    LTEQ            reduce using rule 66 (factor -> NUMBER .)
    GTEQ            reduce using rule 66 (factor -> NUMBER .)
    COMMA           reduce using rule 66 (factor -> NUMBER .)
    ID              reduce using rule 66 (factor -> NUMBER .)
    NUMBER          reduce using rule 66 (factor -> NUMBER .)
    STRING          reduce using rule 66 (factor -> NUMBER .)
    TRUE            reduce using rule 66 (factor -> NUMBER .)
    FALSE           reduce using rule 66 (factor -> NUMBER .)
    LPAREN          reduce using rule 66 (factor -> NUMBER .)


state 26

    (67) factor -> STRING .

    MINUS           reduce using rule 67 (factor -> STRING .)
    MUL             reduce using rule 67 (factor -> STRING .)
    PLUS            reduce using rule 67 (factor -> STRING .)
    DIV             reduce using rule 67 (factor -> STRING .)
    REM             reduce using rule 67 (factor -> STRING .)
    PLUSPLUS        reduce using rule 67 (factor -> STRING .)
    MINUSMINUS      reduce using rule 67 (factor -> STRING .)
    SEMICOLON       reduce using rule 67 (factor -> STRING .)
    RPAREN          reduce using rule 67 (factor -> STRING .)
    RSPAREN         reduce using rule 67 (factor -> STRING .)
    EQEQ            reduce using rule 67 (factor -> STRING .)
    NOTEQ           reduce using rule 67 (factor -> STRING .)
    LT              reduce using rule 67 (factor -> STRING .)
    GT              reduce using rule 67 (factor -> STRING .)
    LTEQ            reduce using rule 67 (factor -> STRING .)
    GTEQ            reduce using rule 67 (factor -> STRING .)
    COMMA           reduce using rule 67 (factor -> STRING .)
    ID              reduce using rule 67 (factor -> STRING .)
    NUMBER          reduce using rule 67 (factor -> STRING .)
    STRING          reduce using rule 67 (factor -> STRING .)
    TRUE            reduce using rule 67 (factor -> STRING .)
    FALSE           reduce using rule 67 (factor -> STRING .)
    LPAREN          reduce using rule 67 (factor -> STRING .)


state 27

    (68) factor -> TRUE .

    MINUS           reduce using rule 68 (factor -> TRUE .)
    MUL             reduce using rule 68 (factor -> TRUE .)
    PLUS            reduce using rule 68 (factor -> TRUE .)
    DIV             reduce using rule 68 (factor -> TRUE .)
    REM             reduce using rule 68 (factor -> TRUE .)
    PLUSPLUS        reduce using rule 68 (factor -> TRUE .)
    MINUSMINUS      reduce using rule 68 (factor -> TRUE .)
    SEMICOLON       reduce using rule 68 (factor -> TRUE .)
    RPAREN          reduce using rule 68 (factor -> TRUE .)
    RSPAREN         reduce using rule 68 (factor -> TRUE .)
    EQEQ            reduce using rule 68 (factor -> TRUE .)
    NOTEQ           reduce using rule 68 (factor -> TRUE .)
    LT              reduce using rule 68 (factor -> TRUE .)
    GT              reduce using rule 68 (factor -> TRUE .)
    LTEQ            reduce using rule 68 (factor -> TRUE .)
    GTEQ            reduce using rule 68 (factor -> TRUE .)
    COMMA           reduce using rule 68 (factor -> TRUE .)
    ID              reduce using rule 68 (factor -> TRUE .)
    NUMBER          reduce using rule 68 (factor -> TRUE .)
    STRING          reduce using rule 68 (factor -> TRUE .)
    TRUE            reduce using rule 68 (factor -> TRUE .)
    FALSE           reduce using rule 68 (factor -> TRUE .)
    LPAREN          reduce using rule 68 (factor -> TRUE .)


state 28

    (69) factor -> FALSE .

    MINUS           reduce using rule 69 (factor -> FALSE .)
    MUL             reduce using rule 69 (factor -> FALSE .)
    PLUS            reduce using rule 69 (factor -> FALSE .)
    DIV             reduce using rule 69 (factor -> FALSE .)
    REM             reduce using rule 69 (factor -> FALSE .)
    PLUSPLUS        reduce using rule 69 (factor -> FALSE .)
    MINUSMINUS      reduce using rule 69 (factor -> FALSE .)
    SEMICOLON       reduce using rule 69 (factor -> FALSE .)
    RPAREN          reduce using rule 69 (factor -> FALSE .)
    RSPAREN         reduce using rule 69 (factor -> FALSE .)
    EQEQ            reduce using rule 69 (factor -> FALSE .)
    NOTEQ           reduce using rule 69 (factor -> FALSE .)
    LT              reduce using rule 69 (factor -> FALSE .)
    GT              reduce using rule 69 (factor -> FALSE .)
    LTEQ            reduce using rule 69 (factor -> FALSE .)
    GTEQ            reduce using rule 69 (factor -> FALSE .)
    COMMA           reduce using rule 69 (factor -> FALSE .)
    ID              reduce using rule 69 (factor -> FALSE .)
    NUMBER          reduce using rule 69 (factor -> FALSE .)
    STRING          reduce using rule 69 (factor -> FALSE .)
    TRUE            reduce using rule 69 (factor -> FALSE .)
    FALSE           reduce using rule 69 (factor -> FALSE .)
    LPAREN          reduce using rule 69 (factor -> FALSE .)


state 29

    (22) A -> TUPLE .

    ID              reduce using rule 22 (A -> TUPLE .)


state 30

    (23) A -> LIST .

    ID              reduce using rule 23 (A -> LIST .)


state 31

    (2) statement_list -> statement_list statement SEMICOLON .

    VAR             reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    ID              reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    IF              reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    WHILE           reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    FUNC            reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    BEGIN           reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    ZOUT            reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    NUMBER          reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    STRING          reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    TRUE            reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    FALSE           reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    LPAREN          reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    TUPLE           reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    LIST            reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    $end            reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    EXCEPT          reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    END             reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)
    RETURN          reduce using rule 2 (statement_list -> statement_list statement SEMICOLON .)


state 32

    (55) expression -> expression binary_operator . expression
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    expression                     shift and go to state 56
    factor                         shift and go to state 22

state 33

    (56) expression -> expression unary_operator .

    MINUS           reduce using rule 56 (expression -> expression unary_operator .)
    MUL             reduce using rule 56 (expression -> expression unary_operator .)
    PLUS            reduce using rule 56 (expression -> expression unary_operator .)
    DIV             reduce using rule 56 (expression -> expression unary_operator .)
    REM             reduce using rule 56 (expression -> expression unary_operator .)
    PLUSPLUS        reduce using rule 56 (expression -> expression unary_operator .)
    MINUSMINUS      reduce using rule 56 (expression -> expression unary_operator .)
    SEMICOLON       reduce using rule 56 (expression -> expression unary_operator .)
    RPAREN          reduce using rule 56 (expression -> expression unary_operator .)
    RSPAREN         reduce using rule 56 (expression -> expression unary_operator .)
    EQEQ            reduce using rule 56 (expression -> expression unary_operator .)
    NOTEQ           reduce using rule 56 (expression -> expression unary_operator .)
    LT              reduce using rule 56 (expression -> expression unary_operator .)
    GT              reduce using rule 56 (expression -> expression unary_operator .)
    LTEQ            reduce using rule 56 (expression -> expression unary_operator .)
    GTEQ            reduce using rule 56 (expression -> expression unary_operator .)
    COMMA           reduce using rule 56 (expression -> expression unary_operator .)
    ID              reduce using rule 56 (expression -> expression unary_operator .)
    NUMBER          reduce using rule 56 (expression -> expression unary_operator .)
    STRING          reduce using rule 56 (expression -> expression unary_operator .)
    TRUE            reduce using rule 56 (expression -> expression unary_operator .)
    FALSE           reduce using rule 56 (expression -> expression unary_operator .)
    LPAREN          reduce using rule 56 (expression -> expression unary_operator .)


state 34

    (58) binary_operator -> MINUS .

    ID              reduce using rule 58 (binary_operator -> MINUS .)
    NUMBER          reduce using rule 58 (binary_operator -> MINUS .)
    STRING          reduce using rule 58 (binary_operator -> MINUS .)
    TRUE            reduce using rule 58 (binary_operator -> MINUS .)
    FALSE           reduce using rule 58 (binary_operator -> MINUS .)
    LPAREN          reduce using rule 58 (binary_operator -> MINUS .)


state 35

    (59) binary_operator -> MUL .

    ID              reduce using rule 59 (binary_operator -> MUL .)
    NUMBER          reduce using rule 59 (binary_operator -> MUL .)
    STRING          reduce using rule 59 (binary_operator -> MUL .)
    TRUE            reduce using rule 59 (binary_operator -> MUL .)
    FALSE           reduce using rule 59 (binary_operator -> MUL .)
    LPAREN          reduce using rule 59 (binary_operator -> MUL .)


state 36

    (60) binary_operator -> PLUS .

    ID              reduce using rule 60 (binary_operator -> PLUS .)
    NUMBER          reduce using rule 60 (binary_operator -> PLUS .)
    STRING          reduce using rule 60 (binary_operator -> PLUS .)
    TRUE            reduce using rule 60 (binary_operator -> PLUS .)
    FALSE           reduce using rule 60 (binary_operator -> PLUS .)
    LPAREN          reduce using rule 60 (binary_operator -> PLUS .)


state 37

    (61) binary_operator -> DIV .

    ID              reduce using rule 61 (binary_operator -> DIV .)
    NUMBER          reduce using rule 61 (binary_operator -> DIV .)
    STRING          reduce using rule 61 (binary_operator -> DIV .)
    TRUE            reduce using rule 61 (binary_operator -> DIV .)
    FALSE           reduce using rule 61 (binary_operator -> DIV .)
    LPAREN          reduce using rule 61 (binary_operator -> DIV .)


state 38

    (62) binary_operator -> REM .

    ID              reduce using rule 62 (binary_operator -> REM .)
    NUMBER          reduce using rule 62 (binary_operator -> REM .)
    STRING          reduce using rule 62 (binary_operator -> REM .)
    TRUE            reduce using rule 62 (binary_operator -> REM .)
    FALSE           reduce using rule 62 (binary_operator -> REM .)
    LPAREN          reduce using rule 62 (binary_operator -> REM .)


state 39

    (63) unary_operator -> PLUSPLUS .

    MINUS           reduce using rule 63 (unary_operator -> PLUSPLUS .)
    MUL             reduce using rule 63 (unary_operator -> PLUSPLUS .)
    PLUS            reduce using rule 63 (unary_operator -> PLUSPLUS .)
    DIV             reduce using rule 63 (unary_operator -> PLUSPLUS .)
    REM             reduce using rule 63 (unary_operator -> PLUSPLUS .)
    PLUSPLUS        reduce using rule 63 (unary_operator -> PLUSPLUS .)
    MINUSMINUS      reduce using rule 63 (unary_operator -> PLUSPLUS .)
    SEMICOLON       reduce using rule 63 (unary_operator -> PLUSPLUS .)
    RPAREN          reduce using rule 63 (unary_operator -> PLUSPLUS .)
    RSPAREN         reduce using rule 63 (unary_operator -> PLUSPLUS .)
    EQEQ            reduce using rule 63 (unary_operator -> PLUSPLUS .)
    NOTEQ           reduce using rule 63 (unary_operator -> PLUSPLUS .)
    LT              reduce using rule 63 (unary_operator -> PLUSPLUS .)
    GT              reduce using rule 63 (unary_operator -> PLUSPLUS .)
    LTEQ            reduce using rule 63 (unary_operator -> PLUSPLUS .)
    GTEQ            reduce using rule 63 (unary_operator -> PLUSPLUS .)
    COMMA           reduce using rule 63 (unary_operator -> PLUSPLUS .)
    ID              reduce using rule 63 (unary_operator -> PLUSPLUS .)
    NUMBER          reduce using rule 63 (unary_operator -> PLUSPLUS .)
    STRING          reduce using rule 63 (unary_operator -> PLUSPLUS .)
    TRUE            reduce using rule 63 (unary_operator -> PLUSPLUS .)
    FALSE           reduce using rule 63 (unary_operator -> PLUSPLUS .)
    LPAREN          reduce using rule 63 (unary_operator -> PLUSPLUS .)


state 40

    (64) unary_operator -> MINUSMINUS .

    MINUS           reduce using rule 64 (unary_operator -> MINUSMINUS .)
    MUL             reduce using rule 64 (unary_operator -> MINUSMINUS .)
    PLUS            reduce using rule 64 (unary_operator -> MINUSMINUS .)
    DIV             reduce using rule 64 (unary_operator -> MINUSMINUS .)
    REM             reduce using rule 64 (unary_operator -> MINUSMINUS .)
    PLUSPLUS        reduce using rule 64 (unary_operator -> MINUSMINUS .)
    MINUSMINUS      reduce using rule 64 (unary_operator -> MINUSMINUS .)
    SEMICOLON       reduce using rule 64 (unary_operator -> MINUSMINUS .)
    RPAREN          reduce using rule 64 (unary_operator -> MINUSMINUS .)
    RSPAREN         reduce using rule 64 (unary_operator -> MINUSMINUS .)
    EQEQ            reduce using rule 64 (unary_operator -> MINUSMINUS .)
    NOTEQ           reduce using rule 64 (unary_operator -> MINUSMINUS .)
    LT              reduce using rule 64 (unary_operator -> MINUSMINUS .)
    GT              reduce using rule 64 (unary_operator -> MINUSMINUS .)
    LTEQ            reduce using rule 64 (unary_operator -> MINUSMINUS .)
    GTEQ            reduce using rule 64 (unary_operator -> MINUSMINUS .)
    COMMA           reduce using rule 64 (unary_operator -> MINUSMINUS .)
    ID              reduce using rule 64 (unary_operator -> MINUSMINUS .)
    NUMBER          reduce using rule 64 (unary_operator -> MINUSMINUS .)
    STRING          reduce using rule 64 (unary_operator -> MINUSMINUS .)
    TRUE            reduce using rule 64 (unary_operator -> MINUSMINUS .)
    FALSE           reduce using rule 64 (unary_operator -> MINUSMINUS .)
    LPAREN          reduce using rule 64 (unary_operator -> MINUSMINUS .)


state 41

    (14) declaration -> VAR type . assignment
    (15) assignment -> . ID ASSIGN L

    ID              shift and go to state 58

    assignment                     shift and go to state 57

state 42

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 43

    (19) type -> BOOL .

    ID              reduce using rule 19 (type -> BOOL .)


state 44

    (20) type -> STR .

    ID              reduce using rule 20 (type -> STR .)


state 45

    (15) assignment -> ID ASSIGN . L
    (16) L -> . statement
    (17) L -> . ID LPAREN data RPAREN
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    ID              shift and go to state 59
    VAR             shift and go to state 15
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    L                              shift and go to state 60
    statement                      shift and go to state 61
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 46

    (27) compound_type_access -> ID DOT . F
    (29) F -> . CON LPAREN factor RPAREN
    (30) F -> . FRONT
    (31) F -> . ADD LPAREN factor RPAREN
    (32) F -> . REAR
    (33) F -> . SIZE
    (34) F -> . DELETE
    (35) F -> . SUBSTR LPAREN factor COMMA factor RPAREN
    (36) F -> . empty
    (75) empty -> .

    CON             shift and go to state 63
    FRONT           shift and go to state 64
    ADD             shift and go to state 65
    REAR            shift and go to state 66
    SIZE            shift and go to state 67
    DELETE          shift and go to state 68
    SUBSTR          shift and go to state 69
    SEMICOLON       reduce using rule 75 (empty -> .)
    RPAREN          reduce using rule 75 (empty -> .)

    F                              shift and go to state 62
    empty                          shift and go to state 70

state 47

    (28) compound_type_access -> ID LSPAREN . expression RSPAREN
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    expression                     shift and go to state 71
    factor                         shift and go to state 22

state 48

    (37) if_stmnt -> IF LPAREN . condition RPAREN BEGIN statement_list END T
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    condition                      shift and go to state 72
    expression                     shift and go to state 73
    factor                         shift and go to state 22

state 49

    (70) factor -> LPAREN expression . RPAREN
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    RPAREN          shift and go to state 74
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 50

    (65) factor -> ID .

    RPAREN          reduce using rule 65 (factor -> ID .)
    MINUS           reduce using rule 65 (factor -> ID .)
    MUL             reduce using rule 65 (factor -> ID .)
    PLUS            reduce using rule 65 (factor -> ID .)
    DIV             reduce using rule 65 (factor -> ID .)
    REM             reduce using rule 65 (factor -> ID .)
    PLUSPLUS        reduce using rule 65 (factor -> ID .)
    MINUSMINUS      reduce using rule 65 (factor -> ID .)
    SEMICOLON       reduce using rule 65 (factor -> ID .)
    RSPAREN         reduce using rule 65 (factor -> ID .)
    EQEQ            reduce using rule 65 (factor -> ID .)
    NOTEQ           reduce using rule 65 (factor -> ID .)
    LT              reduce using rule 65 (factor -> ID .)
    GT              reduce using rule 65 (factor -> ID .)
    LTEQ            reduce using rule 65 (factor -> ID .)
    GTEQ            reduce using rule 65 (factor -> ID .)
    COMMA           reduce using rule 65 (factor -> ID .)
    ID              reduce using rule 65 (factor -> ID .)
    NUMBER          reduce using rule 65 (factor -> ID .)
    STRING          reduce using rule 65 (factor -> ID .)
    TRUE            reduce using rule 65 (factor -> ID .)
    FALSE           reduce using rule 65 (factor -> ID .)
    LPAREN          reduce using rule 65 (factor -> ID .)


state 51

    (71) try_except -> BEGIN TRY . statement_list EXCEPT statement_list END
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    EXCEPT          reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 75
    empty                          shift and go to state 3

state 52

    (42) while_stmt -> WHILE LPAREN . condition RPAREN BEGIN statement_list END
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    condition                      shift and go to state 76
    expression                     shift and go to state 73
    factor                         shift and go to state 22

state 53

    (43) function_call -> FUNC ID . LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END

    LPAREN          shift and go to state 77


state 54

    (21) compound_types -> A ID . ASSIGN LPAREN data RPAREN

    ASSIGN          shift and go to state 78


state 55

    (72) print -> ZOUT LPAREN . y RPAREN
    (73) y -> . expression
    (74) y -> . compound_type_access
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 82
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    y                              shift and go to state 79
    expression                     shift and go to state 80
    compound_type_access           shift and go to state 81
    factor                         shift and go to state 22

state 56

    (55) expression -> expression binary_operator expression .
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for REM resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
    SEMICOLON       reduce using rule 55 (expression -> expression binary_operator expression .)
    RPAREN          reduce using rule 55 (expression -> expression binary_operator expression .)
    RSPAREN         reduce using rule 55 (expression -> expression binary_operator expression .)
    EQEQ            reduce using rule 55 (expression -> expression binary_operator expression .)
    NOTEQ           reduce using rule 55 (expression -> expression binary_operator expression .)
    LT              reduce using rule 55 (expression -> expression binary_operator expression .)
    GT              reduce using rule 55 (expression -> expression binary_operator expression .)
    LTEQ            reduce using rule 55 (expression -> expression binary_operator expression .)
    GTEQ            reduce using rule 55 (expression -> expression binary_operator expression .)
    COMMA           reduce using rule 55 (expression -> expression binary_operator expression .)
    ID              reduce using rule 55 (expression -> expression binary_operator expression .)
    NUMBER          reduce using rule 55 (expression -> expression binary_operator expression .)
    STRING          reduce using rule 55 (expression -> expression binary_operator expression .)
    TRUE            reduce using rule 55 (expression -> expression binary_operator expression .)
    FALSE           reduce using rule 55 (expression -> expression binary_operator expression .)
    LPAREN          reduce using rule 55 (expression -> expression binary_operator expression .)
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

  ! MINUS           [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! MUL             [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! PLUS            [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! DIV             [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! REM             [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! PLUSPLUS        [ reduce using rule 55 (expression -> expression binary_operator expression .) ]
  ! MINUSMINUS      [ reduce using rule 55 (expression -> expression binary_operator expression .) ]

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 57

    (14) declaration -> VAR type assignment .

    SEMICOLON       reduce using rule 14 (declaration -> VAR type assignment .)


state 58

    (15) assignment -> ID . ASSIGN L

    ASSIGN          shift and go to state 45


state 59

    (17) L -> ID . LPAREN data RPAREN
    (15) assignment -> ID . ASSIGN L
    (27) compound_type_access -> ID . DOT F
    (28) compound_type_access -> ID . LSPAREN expression RSPAREN
    (65) factor -> ID .

    LPAREN          shift and go to state 83
    ASSIGN          shift and go to state 45
    DOT             shift and go to state 46
    LSPAREN         shift and go to state 47
    MINUS           reduce using rule 65 (factor -> ID .)
    MUL             reduce using rule 65 (factor -> ID .)
    PLUS            reduce using rule 65 (factor -> ID .)
    DIV             reduce using rule 65 (factor -> ID .)
    REM             reduce using rule 65 (factor -> ID .)
    PLUSPLUS        reduce using rule 65 (factor -> ID .)
    MINUSMINUS      reduce using rule 65 (factor -> ID .)
    SEMICOLON       reduce using rule 65 (factor -> ID .)


state 60

    (15) assignment -> ID ASSIGN L .

    SEMICOLON       reduce using rule 15 (assignment -> ID ASSIGN L .)


state 61

    (16) L -> statement .

    SEMICOLON       reduce using rule 16 (L -> statement .)


state 62

    (27) compound_type_access -> ID DOT F .

    SEMICOLON       reduce using rule 27 (compound_type_access -> ID DOT F .)
    RPAREN          reduce using rule 27 (compound_type_access -> ID DOT F .)


state 63

    (29) F -> CON . LPAREN factor RPAREN

    LPAREN          shift and go to state 84


state 64

    (30) F -> FRONT .

    SEMICOLON       reduce using rule 30 (F -> FRONT .)
    RPAREN          reduce using rule 30 (F -> FRONT .)


state 65

    (31) F -> ADD . LPAREN factor RPAREN

    LPAREN          shift and go to state 85


state 66

    (32) F -> REAR .

    SEMICOLON       reduce using rule 32 (F -> REAR .)
    RPAREN          reduce using rule 32 (F -> REAR .)


state 67

    (33) F -> SIZE .

    SEMICOLON       reduce using rule 33 (F -> SIZE .)
    RPAREN          reduce using rule 33 (F -> SIZE .)


state 68

    (34) F -> DELETE .

    SEMICOLON       reduce using rule 34 (F -> DELETE .)
    RPAREN          reduce using rule 34 (F -> DELETE .)


state 69

    (35) F -> SUBSTR . LPAREN factor COMMA factor RPAREN

    LPAREN          shift and go to state 86


state 70

    (36) F -> empty .

    SEMICOLON       reduce using rule 36 (F -> empty .)
    RPAREN          reduce using rule 36 (F -> empty .)


state 71

    (28) compound_type_access -> ID LSPAREN expression . RSPAREN
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    RSPAREN         shift and go to state 87
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 72

    (37) if_stmnt -> IF LPAREN condition . RPAREN BEGIN statement_list END T

    RPAREN          shift and go to state 88


state 73

    (48) condition -> expression . comparison_operator expression
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (49) comparison_operator -> . EQEQ
    (50) comparison_operator -> . NOTEQ
    (51) comparison_operator -> . LT
    (52) comparison_operator -> . GT
    (53) comparison_operator -> . LTEQ
    (54) comparison_operator -> . GTEQ
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    EQEQ            shift and go to state 90
    NOTEQ           shift and go to state 91
    LT              shift and go to state 92
    GT              shift and go to state 93
    LTEQ            shift and go to state 94
    GTEQ            shift and go to state 95
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    comparison_operator            shift and go to state 89
    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 74

    (70) factor -> LPAREN expression RPAREN .

    MINUS           reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    MUL             reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    REM             reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    PLUSPLUS        reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    MINUSMINUS      reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    RSPAREN         reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    NOTEQ           reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    NUMBER          reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    STRING          reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 70 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 70 (factor -> LPAREN expression RPAREN .)


state 75

    (71) try_except -> BEGIN TRY statement_list . EXCEPT statement_list END
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    EXCEPT          shift and go to state 96
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 76

    (42) while_stmt -> WHILE LPAREN condition . RPAREN BEGIN statement_list END

    RPAREN          shift and go to state 97


state 77

    (43) function_call -> FUNC ID LPAREN . parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (44) parameter_list -> . type ID optional_parameter_list
    (45) parameter_list -> . empty
    (18) type -> . INT
    (19) type -> . BOOL
    (20) type -> . STR
    (75) empty -> .

    INT             shift and go to state 42
    BOOL            shift and go to state 43
    STR             shift and go to state 44
    RPAREN          reduce using rule 75 (empty -> .)

    parameter_list                 shift and go to state 98
    type                           shift and go to state 99
    empty                          shift and go to state 100

state 78

    (21) compound_types -> A ID ASSIGN . LPAREN data RPAREN

    LPAREN          shift and go to state 101


state 79

    (72) print -> ZOUT LPAREN y . RPAREN

    RPAREN          shift and go to state 102


state 80

    (73) y -> expression .
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    RPAREN          reduce using rule 73 (y -> expression .)
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 81

    (74) y -> compound_type_access .

    RPAREN          reduce using rule 74 (y -> compound_type_access .)


state 82

    (27) compound_type_access -> ID . DOT F
    (28) compound_type_access -> ID . LSPAREN expression RSPAREN
    (65) factor -> ID .

    DOT             shift and go to state 46
    LSPAREN         shift and go to state 47
    MINUS           reduce using rule 65 (factor -> ID .)
    MUL             reduce using rule 65 (factor -> ID .)
    PLUS            reduce using rule 65 (factor -> ID .)
    DIV             reduce using rule 65 (factor -> ID .)
    REM             reduce using rule 65 (factor -> ID .)
    PLUSPLUS        reduce using rule 65 (factor -> ID .)
    MINUSMINUS      reduce using rule 65 (factor -> ID .)
    RPAREN          reduce using rule 65 (factor -> ID .)


state 83

    (17) L -> ID LPAREN . data RPAREN
    (24) data -> . expression data
    (25) data -> . COMMA data
    (26) data -> . empty
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (75) empty -> .
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 105
    RPAREN          reduce using rule 75 (empty -> .)
    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    data                           shift and go to state 103
    expression                     shift and go to state 104
    empty                          shift and go to state 106
    factor                         shift and go to state 22

state 84

    (29) F -> CON LPAREN . factor RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    factor                         shift and go to state 107

state 85

    (31) F -> ADD LPAREN . factor RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    factor                         shift and go to state 108

state 86

    (35) F -> SUBSTR LPAREN . factor COMMA factor RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    factor                         shift and go to state 109

state 87

    (28) compound_type_access -> ID LSPAREN expression RSPAREN .

    SEMICOLON       reduce using rule 28 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    RPAREN          reduce using rule 28 (compound_type_access -> ID LSPAREN expression RSPAREN .)


state 88

    (37) if_stmnt -> IF LPAREN condition RPAREN . BEGIN statement_list END T

    BEGIN           shift and go to state 110


state 89

    (48) condition -> expression comparison_operator . expression
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    expression                     shift and go to state 111
    factor                         shift and go to state 22

state 90

    (49) comparison_operator -> EQEQ .

    ID              reduce using rule 49 (comparison_operator -> EQEQ .)
    NUMBER          reduce using rule 49 (comparison_operator -> EQEQ .)
    STRING          reduce using rule 49 (comparison_operator -> EQEQ .)
    TRUE            reduce using rule 49 (comparison_operator -> EQEQ .)
    FALSE           reduce using rule 49 (comparison_operator -> EQEQ .)
    LPAREN          reduce using rule 49 (comparison_operator -> EQEQ .)


state 91

    (50) comparison_operator -> NOTEQ .

    ID              reduce using rule 50 (comparison_operator -> NOTEQ .)
    NUMBER          reduce using rule 50 (comparison_operator -> NOTEQ .)
    STRING          reduce using rule 50 (comparison_operator -> NOTEQ .)
    TRUE            reduce using rule 50 (comparison_operator -> NOTEQ .)
    FALSE           reduce using rule 50 (comparison_operator -> NOTEQ .)
    LPAREN          reduce using rule 50 (comparison_operator -> NOTEQ .)


state 92

    (51) comparison_operator -> LT .

    ID              reduce using rule 51 (comparison_operator -> LT .)
    NUMBER          reduce using rule 51 (comparison_operator -> LT .)
    STRING          reduce using rule 51 (comparison_operator -> LT .)
    TRUE            reduce using rule 51 (comparison_operator -> LT .)
    FALSE           reduce using rule 51 (comparison_operator -> LT .)
    LPAREN          reduce using rule 51 (comparison_operator -> LT .)


state 93

    (52) comparison_operator -> GT .

    ID              reduce using rule 52 (comparison_operator -> GT .)
    NUMBER          reduce using rule 52 (comparison_operator -> GT .)
    STRING          reduce using rule 52 (comparison_operator -> GT .)
    TRUE            reduce using rule 52 (comparison_operator -> GT .)
    FALSE           reduce using rule 52 (comparison_operator -> GT .)
    LPAREN          reduce using rule 52 (comparison_operator -> GT .)


state 94

    (53) comparison_operator -> LTEQ .

    ID              reduce using rule 53 (comparison_operator -> LTEQ .)
    NUMBER          reduce using rule 53 (comparison_operator -> LTEQ .)
    STRING          reduce using rule 53 (comparison_operator -> LTEQ .)
    TRUE            reduce using rule 53 (comparison_operator -> LTEQ .)
    FALSE           reduce using rule 53 (comparison_operator -> LTEQ .)
    LPAREN          reduce using rule 53 (comparison_operator -> LTEQ .)


state 95

    (54) comparison_operator -> GTEQ .

    ID              reduce using rule 54 (comparison_operator -> GTEQ .)
    NUMBER          reduce using rule 54 (comparison_operator -> GTEQ .)
    STRING          reduce using rule 54 (comparison_operator -> GTEQ .)
    TRUE            reduce using rule 54 (comparison_operator -> GTEQ .)
    FALSE           reduce using rule 54 (comparison_operator -> GTEQ .)
    LPAREN          reduce using rule 54 (comparison_operator -> GTEQ .)


state 96

    (71) try_except -> BEGIN TRY statement_list EXCEPT . statement_list END
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    END             reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 112
    empty                          shift and go to state 3

state 97

    (42) while_stmt -> WHILE LPAREN condition RPAREN . BEGIN statement_list END

    BEGIN           shift and go to state 113


state 98

    (43) function_call -> FUNC ID LPAREN parameter_list . RPAREN BEGIN statement_list RETURN data SEMICOLON END

    RPAREN          shift and go to state 114


state 99

    (44) parameter_list -> type . ID optional_parameter_list

    ID              shift and go to state 115


state 100

    (45) parameter_list -> empty .

    RPAREN          reduce using rule 45 (parameter_list -> empty .)


state 101

    (21) compound_types -> A ID ASSIGN LPAREN . data RPAREN
    (24) data -> . expression data
    (25) data -> . COMMA data
    (26) data -> . empty
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (75) empty -> .
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 105
    RPAREN          reduce using rule 75 (empty -> .)
    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    data                           shift and go to state 116
    expression                     shift and go to state 104
    empty                          shift and go to state 106
    factor                         shift and go to state 22

state 102

    (72) print -> ZOUT LPAREN y RPAREN .

    SEMICOLON       reduce using rule 72 (print -> ZOUT LPAREN y RPAREN .)


state 103

    (17) L -> ID LPAREN data . RPAREN

    RPAREN          shift and go to state 117


state 104

    (24) data -> expression . data
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (24) data -> . expression data
    (25) data -> . COMMA data
    (26) data -> . empty
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (75) empty -> .
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 105
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40
    RPAREN          reduce using rule 75 (empty -> .)
    SEMICOLON       reduce using rule 75 (empty -> .)
    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    expression                     shift and go to state 104
    data                           shift and go to state 118
    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33
    empty                          shift and go to state 106
    factor                         shift and go to state 22

state 105

    (25) data -> COMMA . data
    (24) data -> . expression data
    (25) data -> . COMMA data
    (26) data -> . empty
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (75) empty -> .
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 105
    RPAREN          reduce using rule 75 (empty -> .)
    SEMICOLON       reduce using rule 75 (empty -> .)
    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    data                           shift and go to state 119
    expression                     shift and go to state 104
    empty                          shift and go to state 106
    factor                         shift and go to state 22

state 106

    (26) data -> empty .

    RPAREN          reduce using rule 26 (data -> empty .)
    SEMICOLON       reduce using rule 26 (data -> empty .)


state 107

    (29) F -> CON LPAREN factor . RPAREN

    RPAREN          shift and go to state 120


state 108

    (31) F -> ADD LPAREN factor . RPAREN

    RPAREN          shift and go to state 121


state 109

    (35) F -> SUBSTR LPAREN factor . COMMA factor RPAREN

    COMMA           shift and go to state 122


state 110

    (37) if_stmnt -> IF LPAREN condition RPAREN BEGIN . statement_list END T
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    END             reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 123
    empty                          shift and go to state 3

state 111

    (48) condition -> expression comparison_operator expression .
    (55) expression -> expression . binary_operator expression
    (56) expression -> expression . unary_operator
    (58) binary_operator -> . MINUS
    (59) binary_operator -> . MUL
    (60) binary_operator -> . PLUS
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM
    (63) unary_operator -> . PLUSPLUS
    (64) unary_operator -> . MINUSMINUS

    RPAREN          reduce using rule 48 (condition -> expression comparison_operator expression .)
    MINUS           shift and go to state 34
    MUL             shift and go to state 35
    PLUS            shift and go to state 36
    DIV             shift and go to state 37
    REM             shift and go to state 38
    PLUSPLUS        shift and go to state 39
    MINUSMINUS      shift and go to state 40

    binary_operator                shift and go to state 32
    unary_operator                 shift and go to state 33

state 112

    (71) try_except -> BEGIN TRY statement_list EXCEPT statement_list . END
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    END             shift and go to state 124
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 113

    (42) while_stmt -> WHILE LPAREN condition RPAREN BEGIN . statement_list END
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    END             reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 125
    empty                          shift and go to state 3

state 114

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN . BEGIN statement_list RETURN data SEMICOLON END

    BEGIN           shift and go to state 126


state 115

    (44) parameter_list -> type ID . optional_parameter_list
    (46) optional_parameter_list -> . COMMA type ID optional_parameter_list
    (47) optional_parameter_list -> . empty
    (75) empty -> .

    COMMA           shift and go to state 128
    RPAREN          reduce using rule 75 (empty -> .)

    optional_parameter_list        shift and go to state 127
    empty                          shift and go to state 129

state 116

    (21) compound_types -> A ID ASSIGN LPAREN data . RPAREN

    RPAREN          shift and go to state 130


state 117

    (17) L -> ID LPAREN data RPAREN .

    SEMICOLON       reduce using rule 17 (L -> ID LPAREN data RPAREN .)


state 118

    (24) data -> expression data .

    RPAREN          reduce using rule 24 (data -> expression data .)
    SEMICOLON       reduce using rule 24 (data -> expression data .)


state 119

    (25) data -> COMMA data .

    RPAREN          reduce using rule 25 (data -> COMMA data .)
    SEMICOLON       reduce using rule 25 (data -> COMMA data .)


state 120

    (29) F -> CON LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 29 (F -> CON LPAREN factor RPAREN .)
    RPAREN          reduce using rule 29 (F -> CON LPAREN factor RPAREN .)


state 121

    (31) F -> ADD LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 31 (F -> ADD LPAREN factor RPAREN .)
    RPAREN          reduce using rule 31 (F -> ADD LPAREN factor RPAREN .)


state 122

    (35) F -> SUBSTR LPAREN factor COMMA . factor RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    factor                         shift and go to state 131

state 123

    (37) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list . END T
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    END             shift and go to state 132
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 124

    (71) try_except -> BEGIN TRY statement_list EXCEPT statement_list END .

    SEMICOLON       reduce using rule 71 (try_except -> BEGIN TRY statement_list EXCEPT statement_list END .)


state 125

    (42) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list . END
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    END             shift and go to state 133
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 126

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN . statement_list RETURN data SEMICOLON END
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    RETURN          reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 134
    empty                          shift and go to state 3

state 127

    (44) parameter_list -> type ID optional_parameter_list .

    RPAREN          reduce using rule 44 (parameter_list -> type ID optional_parameter_list .)


state 128

    (46) optional_parameter_list -> COMMA . type ID optional_parameter_list
    (18) type -> . INT
    (19) type -> . BOOL
    (20) type -> . STR

    INT             shift and go to state 42
    BOOL            shift and go to state 43
    STR             shift and go to state 44

    type                           shift and go to state 135

state 129

    (47) optional_parameter_list -> empty .

    RPAREN          reduce using rule 47 (optional_parameter_list -> empty .)


state 130

    (21) compound_types -> A ID ASSIGN LPAREN data RPAREN .

    SEMICOLON       reduce using rule 21 (compound_types -> A ID ASSIGN LPAREN data RPAREN .)


state 131

    (35) F -> SUBSTR LPAREN factor COMMA factor . RPAREN

    RPAREN          shift and go to state 136


state 132

    (37) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END . T
    (38) T -> . ELIF LPAREN condition RPAREN BEGIN statement_list END K
    (39) T -> . empty
    (75) empty -> .

    ELIF            shift and go to state 138
    SEMICOLON       reduce using rule 75 (empty -> .)

    T                              shift and go to state 137
    empty                          shift and go to state 139

state 133

    (42) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .

    SEMICOLON       reduce using rule 42 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)


state 134

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list . RETURN data SEMICOLON END
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    RETURN          shift and go to state 140
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 135

    (46) optional_parameter_list -> COMMA type . ID optional_parameter_list

    ID              shift and go to state 141


state 136

    (35) F -> SUBSTR LPAREN factor COMMA factor RPAREN .

    SEMICOLON       reduce using rule 35 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    RPAREN          reduce using rule 35 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)


state 137

    (37) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .

    SEMICOLON       reduce using rule 37 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)


state 138

    (38) T -> ELIF . LPAREN condition RPAREN BEGIN statement_list END K

    LPAREN          shift and go to state 142


state 139

    (39) T -> empty .

    SEMICOLON       reduce using rule 39 (T -> empty .)


state 140

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN . data SEMICOLON END
    (24) data -> . expression data
    (25) data -> . COMMA data
    (26) data -> . empty
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (75) empty -> .
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    COMMA           shift and go to state 105
    SEMICOLON       reduce using rule 75 (empty -> .)
    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    data                           shift and go to state 143
    expression                     shift and go to state 104
    empty                          shift and go to state 106
    factor                         shift and go to state 22

state 141

    (46) optional_parameter_list -> COMMA type ID . optional_parameter_list
    (46) optional_parameter_list -> . COMMA type ID optional_parameter_list
    (47) optional_parameter_list -> . empty
    (75) empty -> .

    COMMA           shift and go to state 128
    RPAREN          reduce using rule 75 (empty -> .)

    optional_parameter_list        shift and go to state 144
    empty                          shift and go to state 129

state 142

    (38) T -> ELIF LPAREN . condition RPAREN BEGIN statement_list END K
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 50
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18

    condition                      shift and go to state 145
    expression                     shift and go to state 73
    factor                         shift and go to state 22

state 143

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data . SEMICOLON END

    SEMICOLON       shift and go to state 146


state 144

    (46) optional_parameter_list -> COMMA type ID optional_parameter_list .

    RPAREN          reduce using rule 46 (optional_parameter_list -> COMMA type ID optional_parameter_list .)


state 145

    (38) T -> ELIF LPAREN condition . RPAREN BEGIN statement_list END K

    RPAREN          shift and go to state 147


state 146

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON . END

    END             shift and go to state 148


state 147

    (38) T -> ELIF LPAREN condition RPAREN . BEGIN statement_list END K

    BEGIN           shift and go to state 149


state 148

    (43) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .

    SEMICOLON       reduce using rule 43 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END .)


state 149

    (38) T -> ELIF LPAREN condition RPAREN BEGIN . statement_list END K
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    END             reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 150
    empty                          shift and go to state 3

state 150

    (38) T -> ELIF LPAREN condition RPAREN BEGIN statement_list . END K
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    END             shift and go to state 151
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 151

    (38) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END . K
    (40) K -> . ELSE BEGIN statement_list END
    (41) K -> . empty
    (75) empty -> .

    ELSE            shift and go to state 153
    SEMICOLON       reduce using rule 75 (empty -> .)

    K                              shift and go to state 152
    empty                          shift and go to state 154

state 152

    (38) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .

    SEMICOLON       reduce using rule 38 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)


state 153

    (40) K -> ELSE . BEGIN statement_list END

    BEGIN           shift and go to state 155


state 154

    (41) K -> empty .

    SEMICOLON       reduce using rule 41 (K -> empty .)


state 155

    (40) K -> ELSE BEGIN . statement_list END
    (2) statement_list -> . statement_list statement SEMICOLON
    (3) statement_list -> . empty
    (75) empty -> .

    END             reduce using rule 75 (empty -> .)
    VAR             reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)
    ZOUT            reduce using rule 75 (empty -> .)
    NUMBER          reduce using rule 75 (empty -> .)
    STRING          reduce using rule 75 (empty -> .)
    TRUE            reduce using rule 75 (empty -> .)
    FALSE           reduce using rule 75 (empty -> .)
    LPAREN          reduce using rule 75 (empty -> .)
    TUPLE           reduce using rule 75 (empty -> .)
    LIST            reduce using rule 75 (empty -> .)

    statement_list                 shift and go to state 156
    empty                          shift and go to state 3

state 156

    (40) K -> ELSE BEGIN statement_list . END
    (2) statement_list -> statement_list . statement SEMICOLON
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . expression
    (10) statement -> . compound_types
    (11) statement -> . compound_type_access
    (12) statement -> . try_except
    (13) statement -> . print
    (14) declaration -> . VAR type assignment
    (15) assignment -> . ID ASSIGN L
    (37) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (42) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (43) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN data SEMICOLON END
    (55) expression -> . expression binary_operator expression
    (56) expression -> . expression unary_operator
    (57) expression -> . factor
    (21) compound_types -> . A ID ASSIGN LPAREN data RPAREN
    (27) compound_type_access -> . ID DOT F
    (28) compound_type_access -> . ID LSPAREN expression RSPAREN
    (71) try_except -> . BEGIN TRY statement_list EXCEPT statement_list END
    (72) print -> . ZOUT LPAREN y RPAREN
    (65) factor -> . ID
    (66) factor -> . NUMBER
    (67) factor -> . STRING
    (68) factor -> . TRUE
    (69) factor -> . FALSE
    (70) factor -> . LPAREN expression RPAREN
    (22) A -> . TUPLE
    (23) A -> . LIST

    END             shift and go to state 157
    VAR             shift and go to state 15
    ID              shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 20
    FUNC            shift and go to state 21
    BEGIN           shift and go to state 19
    ZOUT            shift and go to state 24
    NUMBER          shift and go to state 25
    STRING          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    LPAREN          shift and go to state 18
    TUPLE           shift and go to state 29
    LIST            shift and go to state 30

    statement                      shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    expression                     shift and go to state 10
    compound_types                 shift and go to state 11
    compound_type_access           shift and go to state 12
    try_except                     shift and go to state 13
    print                          shift and go to state 14
    factor                         shift and go to state 22
    A                              shift and go to state 23

state 157

    (40) K -> ELSE BEGIN statement_list END .

    SEMICOLON       reduce using rule 40 (K -> ELSE BEGIN statement_list END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MUL in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for DIV in state 56 resolved as shift
WARNING: shift/reduce conflict for REM in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 56 resolved as shift
