Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> statement_list
Rule 2     statement_list -> statement SEMICOLON statement_list
Rule 3     statement_list -> empty
Rule 4     statement -> declaration
Rule 5     statement -> assignment
Rule 6     statement -> if_stmnt
Rule 7     statement -> while_stmt
Rule 8     statement -> function_call
Rule 9     statement -> compound_types
Rule 10    statement -> compound_type_access
Rule 11    statement -> try_except
Rule 12    statement -> print
Rule 13    declaration -> VAR type ID ASSIGN L
Rule 14    L -> expression
Rule 15    L -> compound_type_access
Rule 16    assignment -> ID ASSIGN expression
Rule 17    type -> INT
Rule 18    type -> BOOL
Rule 19    type -> STR
Rule 20    compound_types -> A ID ASSIGN N
Rule 21    A -> TUPLE
Rule 22    A -> LIST
Rule 23    N -> LPAREN data RPAREN
Rule 24    N -> LSPAREN data RSPAREN
Rule 25    data -> factor P
Rule 26    P -> COMMA data P
Rule 27    P -> empty
Rule 28    compound_type_access -> Z F
Rule 29    compound_type_access -> ID LSPAREN expression RSPAREN
Rule 30    Z -> ID DOT
Rule 31    F -> CON LPAREN factor RPAREN
Rule 32    F -> FRONT
Rule 33    F -> REAR
Rule 34    F -> SIZE
Rule 35    F -> DELETE
Rule 36    F -> SUBSTR LPAREN factor COMMA factor RPAREN
Rule 37    F -> empty
Rule 38    if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T
Rule 39    T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K
Rule 40    T -> empty
Rule 41    K -> ELSE BEGIN statement_list END
Rule 42    K -> empty
Rule 43    while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END
Rule 44    function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
Rule 45    parameter_list -> type ID M
Rule 46    M -> COMMA parameter_list
Rule 47    M -> empty
Rule 48    condition -> expression comparison_operator expression
Rule 49    comparison_operator -> EQEQ
Rule 50    comparison_operator -> NOTEQ
Rule 51    comparison_operator -> LT
Rule 52    comparison_operator -> GT
Rule 53    comparison_operator -> LTEQ
Rule 54    comparison_operator -> GTEQ
Rule 55    expression -> D term
Rule 56    D -> expression binary_operator
Rule 57    D -> empty
Rule 58    binary_operator -> PLUS
Rule 59    binary_operator -> MINUS
Rule 60    binary_operator -> MUL
Rule 61    binary_operator -> DIV
Rule 62    binary_operator -> REM
Rule 63    term -> factor
Rule 64    term -> term unary_operator factor
Rule 65    unary_operator -> PLUSPLUS
Rule 66    unary_operator -> MINUSMINUS
Rule 67    factor -> ID
Rule 68    factor -> NUMBER
Rule 69    factor -> STRING
Rule 70    factor -> TRUE
Rule 71    factor -> FALSE
Rule 72    factor -> LPAREN expression RPAREN
Rule 73    try_except -> TRY x EXCEPT x
Rule 74    x -> BEGIN statement_list END
Rule 75    print -> ZOUT LPAREN y RPAREN
Rule 76    y -> NUMBER
Rule 77    y -> STRING
Rule 78    y -> ID
Rule 79    y -> compound_type_access
Rule 80    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 13 16 20
BEGIN                : 38 39 41 43 44 74
BOOL                 : 18
COMMA                : 26 36 46
CON                  : 31
DELETE               : 35
DIV                  : 61
DOT                  : 30
ELIF                 : 39
ELSE                 : 41
END                  : 38 39 41 43 44 74
EQEQ                 : 49
EXCEPT               : 73
FALSE                : 71
FRONT                : 32
FUNC                 : 44
GT                   : 52
GTEQ                 : 54
ID                   : 13 16 20 29 30 44 44 45 67 78
IF                   : 38
INT                  : 17
LIST                 : 22
LPAREN               : 23 31 36 38 39 43 44 72 75
LSPAREN              : 24 29
LT                   : 51
LTEQ                 : 53
MINUS                : 59
MINUSMINUS           : 66
MUL                  : 60
NOTEQ                : 50
NUMBER               : 68 76
PLUS                 : 58
PLUSPLUS             : 65
REAR                 : 33
REM                  : 62
RETURN               : 44
RPAREN               : 23 31 36 38 39 43 44 72 75
RSPAREN              : 24 29
SEMICOLON            : 2 44
SIZE                 : 34
STR                  : 19
STRING               : 69 77
SUBSTR               : 36
TRUE                 : 70
TRY                  : 73
TUPLE                : 21
VAR                  : 13
WHILE                : 43
ZOUT                 : 75
error                : 

Nonterminals, with rules where they appear

A                    : 20
D                    : 55
F                    : 28
K                    : 39
L                    : 13
M                    : 45
N                    : 20
P                    : 25 26
T                    : 38
Z                    : 28
assignment           : 5
binary_operator      : 56
comparison_operator  : 48
compound_type_access : 10 15 79
compound_types       : 9
condition            : 38 39 43
data                 : 23 24 26
declaration          : 4
empty                : 3 27 37 40 42 47 57
expression           : 14 16 29 48 48 56 72
factor               : 25 31 36 36 63 64
function_call        : 8
if_stmnt             : 6
parameter_list       : 44 46
print                : 12
start                : 0
statement            : 2
statement_list       : 1 2 38 39 41 43 44 74
term                 : 55 64
try_except           : 11
type                 : 13 45
unary_operator       : 64
while_stmt           : 7
x                    : 73 73
y                    : 75

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . statement_list
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    $end            reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    start                          shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 1

    (0) S' -> start .



state 2

    (1) start -> statement_list .

    $end            reduce using rule 1 (start -> statement_list .)


state 3

    (2) statement_list -> statement . SEMICOLON statement_list

    SEMICOLON       shift and go to state 25


state 4

    (3) statement_list -> empty .

    $end            reduce using rule 3 (statement_list -> empty .)
    END             reduce using rule 3 (statement_list -> empty .)
    RETURN          reduce using rule 3 (statement_list -> empty .)


state 5

    (4) statement -> declaration .

    SEMICOLON       reduce using rule 4 (statement -> declaration .)


state 6

    (5) statement -> assignment .

    SEMICOLON       reduce using rule 5 (statement -> assignment .)


state 7

    (6) statement -> if_stmnt .

    SEMICOLON       reduce using rule 6 (statement -> if_stmnt .)


state 8

    (7) statement -> while_stmt .

    SEMICOLON       reduce using rule 7 (statement -> while_stmt .)


state 9

    (8) statement -> function_call .

    SEMICOLON       reduce using rule 8 (statement -> function_call .)


state 10

    (9) statement -> compound_types .

    SEMICOLON       reduce using rule 9 (statement -> compound_types .)


state 11

    (10) statement -> compound_type_access .

    SEMICOLON       reduce using rule 10 (statement -> compound_type_access .)


state 12

    (11) statement -> try_except .

    SEMICOLON       reduce using rule 11 (statement -> try_except .)


state 13

    (12) statement -> print .

    SEMICOLON       reduce using rule 12 (statement -> print .)


state 14

    (13) declaration -> VAR . type ID ASSIGN L
    (17) type -> . INT
    (18) type -> . BOOL
    (19) type -> . STR

    INT             shift and go to state 27
    BOOL            shift and go to state 28
    STR             shift and go to state 29

    type                           shift and go to state 26

state 15

    (16) assignment -> ID . ASSIGN expression
    (29) compound_type_access -> ID . LSPAREN expression RSPAREN
    (30) Z -> ID . DOT

    ASSIGN          shift and go to state 30
    LSPAREN         shift and go to state 31
    DOT             shift and go to state 32


state 16

    (38) if_stmnt -> IF . LPAREN condition RPAREN BEGIN statement_list END T

    LPAREN          shift and go to state 33


state 17

    (43) while_stmt -> WHILE . LPAREN condition RPAREN BEGIN statement_list END

    LPAREN          shift and go to state 34


state 18

    (44) function_call -> FUNC . ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END

    ID              shift and go to state 35


state 19

    (20) compound_types -> A . ID ASSIGN N

    ID              shift and go to state 36


state 20

    (28) compound_type_access -> Z . F
    (31) F -> . CON LPAREN factor RPAREN
    (32) F -> . FRONT
    (33) F -> . REAR
    (34) F -> . SIZE
    (35) F -> . DELETE
    (36) F -> . SUBSTR LPAREN factor COMMA factor RPAREN
    (37) F -> . empty
    (80) empty -> .

    CON             shift and go to state 38
    FRONT           shift and go to state 39
    REAR            shift and go to state 40
    SIZE            shift and go to state 41
    DELETE          shift and go to state 42
    SUBSTR          shift and go to state 43
    SEMICOLON       reduce using rule 80 (empty -> .)
    RPAREN          reduce using rule 80 (empty -> .)

    F                              shift and go to state 37
    empty                          shift and go to state 44

state 21

    (73) try_except -> TRY . x EXCEPT x
    (74) x -> . BEGIN statement_list END

    BEGIN           shift and go to state 46

    x                              shift and go to state 45

state 22

    (75) print -> ZOUT . LPAREN y RPAREN

    LPAREN          shift and go to state 47


state 23

    (21) A -> TUPLE .

    ID              reduce using rule 21 (A -> TUPLE .)


state 24

    (22) A -> LIST .

    ID              reduce using rule 22 (A -> LIST .)


state 25

    (2) statement_list -> statement SEMICOLON . statement_list
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    $end            reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement                      shift and go to state 3
    statement_list                 shift and go to state 48
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 26

    (13) declaration -> VAR type . ID ASSIGN L

    ID              shift and go to state 49


state 27

    (17) type -> INT .

    ID              reduce using rule 17 (type -> INT .)


state 28

    (18) type -> BOOL .

    ID              reduce using rule 18 (type -> BOOL .)


state 29

    (19) type -> STR .

    ID              reduce using rule 19 (type -> STR .)


state 30

    (16) assignment -> ID ASSIGN . expression
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    expression                     shift and go to state 50
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 31

    (29) compound_type_access -> ID LSPAREN . expression RSPAREN
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    expression                     shift and go to state 53
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 32

    (30) Z -> ID DOT .

    CON             reduce using rule 30 (Z -> ID DOT .)
    FRONT           reduce using rule 30 (Z -> ID DOT .)
    REAR            reduce using rule 30 (Z -> ID DOT .)
    SIZE            reduce using rule 30 (Z -> ID DOT .)
    DELETE          reduce using rule 30 (Z -> ID DOT .)
    SUBSTR          reduce using rule 30 (Z -> ID DOT .)
    SEMICOLON       reduce using rule 30 (Z -> ID DOT .)
    RPAREN          reduce using rule 30 (Z -> ID DOT .)


state 33

    (38) if_stmnt -> IF LPAREN . condition RPAREN BEGIN statement_list END T
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    condition                      shift and go to state 54
    expression                     shift and go to state 55
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 34

    (43) while_stmt -> WHILE LPAREN . condition RPAREN BEGIN statement_list END
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    condition                      shift and go to state 56
    expression                     shift and go to state 55
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 35

    (44) function_call -> FUNC ID . LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END

    LPAREN          shift and go to state 57


state 36

    (20) compound_types -> A ID . ASSIGN N

    ASSIGN          shift and go to state 58


state 37

    (28) compound_type_access -> Z F .

    SEMICOLON       reduce using rule 28 (compound_type_access -> Z F .)
    RPAREN          reduce using rule 28 (compound_type_access -> Z F .)


state 38

    (31) F -> CON . LPAREN factor RPAREN

    LPAREN          shift and go to state 59


state 39

    (32) F -> FRONT .

    SEMICOLON       reduce using rule 32 (F -> FRONT .)
    RPAREN          reduce using rule 32 (F -> FRONT .)


state 40

    (33) F -> REAR .

    SEMICOLON       reduce using rule 33 (F -> REAR .)
    RPAREN          reduce using rule 33 (F -> REAR .)


state 41

    (34) F -> SIZE .

    SEMICOLON       reduce using rule 34 (F -> SIZE .)
    RPAREN          reduce using rule 34 (F -> SIZE .)


state 42

    (35) F -> DELETE .

    SEMICOLON       reduce using rule 35 (F -> DELETE .)
    RPAREN          reduce using rule 35 (F -> DELETE .)


state 43

    (36) F -> SUBSTR . LPAREN factor COMMA factor RPAREN

    LPAREN          shift and go to state 60


state 44

    (37) F -> empty .

    SEMICOLON       reduce using rule 37 (F -> empty .)
    RPAREN          reduce using rule 37 (F -> empty .)


state 45

    (73) try_except -> TRY x . EXCEPT x

    EXCEPT          shift and go to state 61


state 46

    (74) x -> BEGIN . statement_list END
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    END             reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 62
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 47

    (75) print -> ZOUT LPAREN . y RPAREN
    (76) y -> . NUMBER
    (77) y -> . STRING
    (78) y -> . ID
    (79) y -> . compound_type_access
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (30) Z -> . ID DOT

    NUMBER          shift and go to state 64
    STRING          shift and go to state 65
    ID              shift and go to state 66

    y                              shift and go to state 63
    compound_type_access           shift and go to state 67
    Z                              shift and go to state 20

state 48

    (2) statement_list -> statement SEMICOLON statement_list .

    $end            reduce using rule 2 (statement_list -> statement SEMICOLON statement_list .)
    END             reduce using rule 2 (statement_list -> statement SEMICOLON statement_list .)
    RETURN          reduce using rule 2 (statement_list -> statement SEMICOLON statement_list .)


state 49

    (13) declaration -> VAR type ID . ASSIGN L

    ASSIGN          shift and go to state 68


state 50

    (16) assignment -> ID ASSIGN expression .
    (56) D -> expression . binary_operator
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    SEMICOLON       reduce using rule 16 (assignment -> ID ASSIGN expression .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    binary_operator                shift and go to state 69

state 51

    (55) expression -> D . term
    (63) term -> . factor
    (64) term -> . term unary_operator factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    term                           shift and go to state 75
    factor                         shift and go to state 76

state 52

    (57) D -> empty .

    ID              reduce using rule 57 (D -> empty .)
    NUMBER          reduce using rule 57 (D -> empty .)
    STRING          reduce using rule 57 (D -> empty .)
    TRUE            reduce using rule 57 (D -> empty .)
    FALSE           reduce using rule 57 (D -> empty .)
    LPAREN          reduce using rule 57 (D -> empty .)


state 53

    (29) compound_type_access -> ID LSPAREN expression . RSPAREN
    (56) D -> expression . binary_operator
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    RSPAREN         shift and go to state 83
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    binary_operator                shift and go to state 69

state 54

    (38) if_stmnt -> IF LPAREN condition . RPAREN BEGIN statement_list END T

    RPAREN          shift and go to state 84


state 55

    (48) condition -> expression . comparison_operator expression
    (56) D -> expression . binary_operator
    (49) comparison_operator -> . EQEQ
    (50) comparison_operator -> . NOTEQ
    (51) comparison_operator -> . LT
    (52) comparison_operator -> . GT
    (53) comparison_operator -> . LTEQ
    (54) comparison_operator -> . GTEQ
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    EQEQ            shift and go to state 86
    NOTEQ           shift and go to state 87
    LT              shift and go to state 88
    GT              shift and go to state 89
    LTEQ            shift and go to state 90
    GTEQ            shift and go to state 91
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    comparison_operator            shift and go to state 85
    binary_operator                shift and go to state 69

state 56

    (43) while_stmt -> WHILE LPAREN condition . RPAREN BEGIN statement_list END

    RPAREN          shift and go to state 92


state 57

    (44) function_call -> FUNC ID LPAREN . parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (45) parameter_list -> . type ID M
    (17) type -> . INT
    (18) type -> . BOOL
    (19) type -> . STR

    INT             shift and go to state 27
    BOOL            shift and go to state 28
    STR             shift and go to state 29

    parameter_list                 shift and go to state 93
    type                           shift and go to state 94

state 58

    (20) compound_types -> A ID ASSIGN . N
    (23) N -> . LPAREN data RPAREN
    (24) N -> . LSPAREN data RSPAREN

    LPAREN          shift and go to state 96
    LSPAREN         shift and go to state 97

    N                              shift and go to state 95

state 59

    (31) F -> CON LPAREN . factor RPAREN
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    factor                         shift and go to state 98

state 60

    (36) F -> SUBSTR LPAREN . factor COMMA factor RPAREN
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    factor                         shift and go to state 99

state 61

    (73) try_except -> TRY x EXCEPT . x
    (74) x -> . BEGIN statement_list END

    BEGIN           shift and go to state 46

    x                              shift and go to state 100

state 62

    (74) x -> BEGIN statement_list . END

    END             shift and go to state 101


state 63

    (75) print -> ZOUT LPAREN y . RPAREN

    RPAREN          shift and go to state 102


state 64

    (76) y -> NUMBER .

    RPAREN          reduce using rule 76 (y -> NUMBER .)


state 65

    (77) y -> STRING .

    RPAREN          reduce using rule 77 (y -> STRING .)


state 66

    (78) y -> ID .
    (29) compound_type_access -> ID . LSPAREN expression RSPAREN
    (30) Z -> ID . DOT

    RPAREN          reduce using rule 78 (y -> ID .)
    LSPAREN         shift and go to state 31
    DOT             shift and go to state 32


state 67

    (79) y -> compound_type_access .

    RPAREN          reduce using rule 79 (y -> compound_type_access .)


state 68

    (13) declaration -> VAR type ID ASSIGN . L
    (14) L -> . expression
    (15) L -> . compound_type_access
    (55) expression -> . D term
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (30) Z -> . ID DOT
    (80) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 103
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

  ! ID              [ reduce using rule 80 (empty -> .) ]

    L                              shift and go to state 104
    expression                     shift and go to state 105
    compound_type_access           shift and go to state 106
    D                              shift and go to state 51
    Z                              shift and go to state 20
    empty                          shift and go to state 52

state 69

    (56) D -> expression binary_operator .

    ID              reduce using rule 56 (D -> expression binary_operator .)
    NUMBER          reduce using rule 56 (D -> expression binary_operator .)
    STRING          reduce using rule 56 (D -> expression binary_operator .)
    TRUE            reduce using rule 56 (D -> expression binary_operator .)
    FALSE           reduce using rule 56 (D -> expression binary_operator .)
    LPAREN          reduce using rule 56 (D -> expression binary_operator .)


state 70

    (58) binary_operator -> PLUS .

    ID              reduce using rule 58 (binary_operator -> PLUS .)
    NUMBER          reduce using rule 58 (binary_operator -> PLUS .)
    STRING          reduce using rule 58 (binary_operator -> PLUS .)
    TRUE            reduce using rule 58 (binary_operator -> PLUS .)
    FALSE           reduce using rule 58 (binary_operator -> PLUS .)
    LPAREN          reduce using rule 58 (binary_operator -> PLUS .)


state 71

    (59) binary_operator -> MINUS .

    ID              reduce using rule 59 (binary_operator -> MINUS .)
    NUMBER          reduce using rule 59 (binary_operator -> MINUS .)
    STRING          reduce using rule 59 (binary_operator -> MINUS .)
    TRUE            reduce using rule 59 (binary_operator -> MINUS .)
    FALSE           reduce using rule 59 (binary_operator -> MINUS .)
    LPAREN          reduce using rule 59 (binary_operator -> MINUS .)


state 72

    (60) binary_operator -> MUL .

    ID              reduce using rule 60 (binary_operator -> MUL .)
    NUMBER          reduce using rule 60 (binary_operator -> MUL .)
    STRING          reduce using rule 60 (binary_operator -> MUL .)
    TRUE            reduce using rule 60 (binary_operator -> MUL .)
    FALSE           reduce using rule 60 (binary_operator -> MUL .)
    LPAREN          reduce using rule 60 (binary_operator -> MUL .)


state 73

    (61) binary_operator -> DIV .

    ID              reduce using rule 61 (binary_operator -> DIV .)
    NUMBER          reduce using rule 61 (binary_operator -> DIV .)
    STRING          reduce using rule 61 (binary_operator -> DIV .)
    TRUE            reduce using rule 61 (binary_operator -> DIV .)
    FALSE           reduce using rule 61 (binary_operator -> DIV .)
    LPAREN          reduce using rule 61 (binary_operator -> DIV .)


state 74

    (62) binary_operator -> REM .

    ID              reduce using rule 62 (binary_operator -> REM .)
    NUMBER          reduce using rule 62 (binary_operator -> REM .)
    STRING          reduce using rule 62 (binary_operator -> REM .)
    TRUE            reduce using rule 62 (binary_operator -> REM .)
    FALSE           reduce using rule 62 (binary_operator -> REM .)
    LPAREN          reduce using rule 62 (binary_operator -> REM .)


state 75

    (55) expression -> D term .
    (64) term -> term . unary_operator factor
    (65) unary_operator -> . PLUSPLUS
    (66) unary_operator -> . MINUSMINUS

    PLUS            reduce using rule 55 (expression -> D term .)
    MINUS           reduce using rule 55 (expression -> D term .)
    MUL             reduce using rule 55 (expression -> D term .)
    DIV             reduce using rule 55 (expression -> D term .)
    REM             reduce using rule 55 (expression -> D term .)
    SEMICOLON       reduce using rule 55 (expression -> D term .)
    RSPAREN         reduce using rule 55 (expression -> D term .)
    EQEQ            reduce using rule 55 (expression -> D term .)
    NOTEQ           reduce using rule 55 (expression -> D term .)
    LT              reduce using rule 55 (expression -> D term .)
    GT              reduce using rule 55 (expression -> D term .)
    LTEQ            reduce using rule 55 (expression -> D term .)
    GTEQ            reduce using rule 55 (expression -> D term .)
    RPAREN          reduce using rule 55 (expression -> D term .)
    PLUSPLUS        shift and go to state 108
    MINUSMINUS      shift and go to state 109

    unary_operator                 shift and go to state 107

state 76

    (63) term -> factor .

    PLUSPLUS        reduce using rule 63 (term -> factor .)
    MINUSMINUS      reduce using rule 63 (term -> factor .)
    PLUS            reduce using rule 63 (term -> factor .)
    MINUS           reduce using rule 63 (term -> factor .)
    MUL             reduce using rule 63 (term -> factor .)
    DIV             reduce using rule 63 (term -> factor .)
    REM             reduce using rule 63 (term -> factor .)
    SEMICOLON       reduce using rule 63 (term -> factor .)
    RSPAREN         reduce using rule 63 (term -> factor .)
    EQEQ            reduce using rule 63 (term -> factor .)
    NOTEQ           reduce using rule 63 (term -> factor .)
    LT              reduce using rule 63 (term -> factor .)
    GT              reduce using rule 63 (term -> factor .)
    LTEQ            reduce using rule 63 (term -> factor .)
    GTEQ            reduce using rule 63 (term -> factor .)
    RPAREN          reduce using rule 63 (term -> factor .)


state 77

    (67) factor -> ID .

    PLUSPLUS        reduce using rule 67 (factor -> ID .)
    MINUSMINUS      reduce using rule 67 (factor -> ID .)
    PLUS            reduce using rule 67 (factor -> ID .)
    MINUS           reduce using rule 67 (factor -> ID .)
    MUL             reduce using rule 67 (factor -> ID .)
    DIV             reduce using rule 67 (factor -> ID .)
    REM             reduce using rule 67 (factor -> ID .)
    SEMICOLON       reduce using rule 67 (factor -> ID .)
    RSPAREN         reduce using rule 67 (factor -> ID .)
    EQEQ            reduce using rule 67 (factor -> ID .)
    NOTEQ           reduce using rule 67 (factor -> ID .)
    LT              reduce using rule 67 (factor -> ID .)
    GT              reduce using rule 67 (factor -> ID .)
    LTEQ            reduce using rule 67 (factor -> ID .)
    GTEQ            reduce using rule 67 (factor -> ID .)
    RPAREN          reduce using rule 67 (factor -> ID .)
    COMMA           reduce using rule 67 (factor -> ID .)


state 78

    (68) factor -> NUMBER .

    PLUSPLUS        reduce using rule 68 (factor -> NUMBER .)
    MINUSMINUS      reduce using rule 68 (factor -> NUMBER .)
    PLUS            reduce using rule 68 (factor -> NUMBER .)
    MINUS           reduce using rule 68 (factor -> NUMBER .)
    MUL             reduce using rule 68 (factor -> NUMBER .)
    DIV             reduce using rule 68 (factor -> NUMBER .)
    REM             reduce using rule 68 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 68 (factor -> NUMBER .)
    RSPAREN         reduce using rule 68 (factor -> NUMBER .)
    EQEQ            reduce using rule 68 (factor -> NUMBER .)
    NOTEQ           reduce using rule 68 (factor -> NUMBER .)
    LT              reduce using rule 68 (factor -> NUMBER .)
    GT              reduce using rule 68 (factor -> NUMBER .)
    LTEQ            reduce using rule 68 (factor -> NUMBER .)
    GTEQ            reduce using rule 68 (factor -> NUMBER .)
    RPAREN          reduce using rule 68 (factor -> NUMBER .)
    COMMA           reduce using rule 68 (factor -> NUMBER .)


state 79

    (69) factor -> STRING .

    PLUSPLUS        reduce using rule 69 (factor -> STRING .)
    MINUSMINUS      reduce using rule 69 (factor -> STRING .)
    PLUS            reduce using rule 69 (factor -> STRING .)
    MINUS           reduce using rule 69 (factor -> STRING .)
    MUL             reduce using rule 69 (factor -> STRING .)
    DIV             reduce using rule 69 (factor -> STRING .)
    REM             reduce using rule 69 (factor -> STRING .)
    SEMICOLON       reduce using rule 69 (factor -> STRING .)
    RSPAREN         reduce using rule 69 (factor -> STRING .)
    EQEQ            reduce using rule 69 (factor -> STRING .)
    NOTEQ           reduce using rule 69 (factor -> STRING .)
    LT              reduce using rule 69 (factor -> STRING .)
    GT              reduce using rule 69 (factor -> STRING .)
    LTEQ            reduce using rule 69 (factor -> STRING .)
    GTEQ            reduce using rule 69 (factor -> STRING .)
    RPAREN          reduce using rule 69 (factor -> STRING .)
    COMMA           reduce using rule 69 (factor -> STRING .)


state 80

    (70) factor -> TRUE .

    PLUSPLUS        reduce using rule 70 (factor -> TRUE .)
    MINUSMINUS      reduce using rule 70 (factor -> TRUE .)
    PLUS            reduce using rule 70 (factor -> TRUE .)
    MINUS           reduce using rule 70 (factor -> TRUE .)
    MUL             reduce using rule 70 (factor -> TRUE .)
    DIV             reduce using rule 70 (factor -> TRUE .)
    REM             reduce using rule 70 (factor -> TRUE .)
    SEMICOLON       reduce using rule 70 (factor -> TRUE .)
    RSPAREN         reduce using rule 70 (factor -> TRUE .)
    EQEQ            reduce using rule 70 (factor -> TRUE .)
    NOTEQ           reduce using rule 70 (factor -> TRUE .)
    LT              reduce using rule 70 (factor -> TRUE .)
    GT              reduce using rule 70 (factor -> TRUE .)
    LTEQ            reduce using rule 70 (factor -> TRUE .)
    GTEQ            reduce using rule 70 (factor -> TRUE .)
    RPAREN          reduce using rule 70 (factor -> TRUE .)
    COMMA           reduce using rule 70 (factor -> TRUE .)


state 81

    (71) factor -> FALSE .

    PLUSPLUS        reduce using rule 71 (factor -> FALSE .)
    MINUSMINUS      reduce using rule 71 (factor -> FALSE .)
    PLUS            reduce using rule 71 (factor -> FALSE .)
    MINUS           reduce using rule 71 (factor -> FALSE .)
    MUL             reduce using rule 71 (factor -> FALSE .)
    DIV             reduce using rule 71 (factor -> FALSE .)
    REM             reduce using rule 71 (factor -> FALSE .)
    SEMICOLON       reduce using rule 71 (factor -> FALSE .)
    RSPAREN         reduce using rule 71 (factor -> FALSE .)
    EQEQ            reduce using rule 71 (factor -> FALSE .)
    NOTEQ           reduce using rule 71 (factor -> FALSE .)
    LT              reduce using rule 71 (factor -> FALSE .)
    GT              reduce using rule 71 (factor -> FALSE .)
    LTEQ            reduce using rule 71 (factor -> FALSE .)
    GTEQ            reduce using rule 71 (factor -> FALSE .)
    RPAREN          reduce using rule 71 (factor -> FALSE .)
    COMMA           reduce using rule 71 (factor -> FALSE .)


state 82

    (72) factor -> LPAREN . expression RPAREN
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    expression                     shift and go to state 110
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 83

    (29) compound_type_access -> ID LSPAREN expression RSPAREN .

    SEMICOLON       reduce using rule 29 (compound_type_access -> ID LSPAREN expression RSPAREN .)
    RPAREN          reduce using rule 29 (compound_type_access -> ID LSPAREN expression RSPAREN .)


state 84

    (38) if_stmnt -> IF LPAREN condition RPAREN . BEGIN statement_list END T

    BEGIN           shift and go to state 111


state 85

    (48) condition -> expression comparison_operator . expression
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    expression                     shift and go to state 112
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 86

    (49) comparison_operator -> EQEQ .

    ID              reduce using rule 49 (comparison_operator -> EQEQ .)
    NUMBER          reduce using rule 49 (comparison_operator -> EQEQ .)
    STRING          reduce using rule 49 (comparison_operator -> EQEQ .)
    TRUE            reduce using rule 49 (comparison_operator -> EQEQ .)
    FALSE           reduce using rule 49 (comparison_operator -> EQEQ .)
    LPAREN          reduce using rule 49 (comparison_operator -> EQEQ .)


state 87

    (50) comparison_operator -> NOTEQ .

    ID              reduce using rule 50 (comparison_operator -> NOTEQ .)
    NUMBER          reduce using rule 50 (comparison_operator -> NOTEQ .)
    STRING          reduce using rule 50 (comparison_operator -> NOTEQ .)
    TRUE            reduce using rule 50 (comparison_operator -> NOTEQ .)
    FALSE           reduce using rule 50 (comparison_operator -> NOTEQ .)
    LPAREN          reduce using rule 50 (comparison_operator -> NOTEQ .)


state 88

    (51) comparison_operator -> LT .

    ID              reduce using rule 51 (comparison_operator -> LT .)
    NUMBER          reduce using rule 51 (comparison_operator -> LT .)
    STRING          reduce using rule 51 (comparison_operator -> LT .)
    TRUE            reduce using rule 51 (comparison_operator -> LT .)
    FALSE           reduce using rule 51 (comparison_operator -> LT .)
    LPAREN          reduce using rule 51 (comparison_operator -> LT .)


state 89

    (52) comparison_operator -> GT .

    ID              reduce using rule 52 (comparison_operator -> GT .)
    NUMBER          reduce using rule 52 (comparison_operator -> GT .)
    STRING          reduce using rule 52 (comparison_operator -> GT .)
    TRUE            reduce using rule 52 (comparison_operator -> GT .)
    FALSE           reduce using rule 52 (comparison_operator -> GT .)
    LPAREN          reduce using rule 52 (comparison_operator -> GT .)


state 90

    (53) comparison_operator -> LTEQ .

    ID              reduce using rule 53 (comparison_operator -> LTEQ .)
    NUMBER          reduce using rule 53 (comparison_operator -> LTEQ .)
    STRING          reduce using rule 53 (comparison_operator -> LTEQ .)
    TRUE            reduce using rule 53 (comparison_operator -> LTEQ .)
    FALSE           reduce using rule 53 (comparison_operator -> LTEQ .)
    LPAREN          reduce using rule 53 (comparison_operator -> LTEQ .)


state 91

    (54) comparison_operator -> GTEQ .

    ID              reduce using rule 54 (comparison_operator -> GTEQ .)
    NUMBER          reduce using rule 54 (comparison_operator -> GTEQ .)
    STRING          reduce using rule 54 (comparison_operator -> GTEQ .)
    TRUE            reduce using rule 54 (comparison_operator -> GTEQ .)
    FALSE           reduce using rule 54 (comparison_operator -> GTEQ .)
    LPAREN          reduce using rule 54 (comparison_operator -> GTEQ .)


state 92

    (43) while_stmt -> WHILE LPAREN condition RPAREN . BEGIN statement_list END

    BEGIN           shift and go to state 113


state 93

    (44) function_call -> FUNC ID LPAREN parameter_list . RPAREN BEGIN statement_list RETURN ID SEMICOLON END

    RPAREN          shift and go to state 114


state 94

    (45) parameter_list -> type . ID M

    ID              shift and go to state 115


state 95

    (20) compound_types -> A ID ASSIGN N .

    SEMICOLON       reduce using rule 20 (compound_types -> A ID ASSIGN N .)


state 96

    (23) N -> LPAREN . data RPAREN
    (25) data -> . factor P
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    data                           shift and go to state 116
    factor                         shift and go to state 117

state 97

    (24) N -> LSPAREN . data RSPAREN
    (25) data -> . factor P
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    data                           shift and go to state 118
    factor                         shift and go to state 117

state 98

    (31) F -> CON LPAREN factor . RPAREN

    RPAREN          shift and go to state 119


state 99

    (36) F -> SUBSTR LPAREN factor . COMMA factor RPAREN

    COMMA           shift and go to state 120


state 100

    (73) try_except -> TRY x EXCEPT x .

    SEMICOLON       reduce using rule 73 (try_except -> TRY x EXCEPT x .)


state 101

    (74) x -> BEGIN statement_list END .

    EXCEPT          reduce using rule 74 (x -> BEGIN statement_list END .)
    SEMICOLON       reduce using rule 74 (x -> BEGIN statement_list END .)


state 102

    (75) print -> ZOUT LPAREN y RPAREN .

    SEMICOLON       reduce using rule 75 (print -> ZOUT LPAREN y RPAREN .)


state 103

    (29) compound_type_access -> ID . LSPAREN expression RSPAREN
    (30) Z -> ID . DOT

    LSPAREN         shift and go to state 31
    DOT             shift and go to state 32


state 104

    (13) declaration -> VAR type ID ASSIGN L .

    SEMICOLON       reduce using rule 13 (declaration -> VAR type ID ASSIGN L .)


state 105

    (14) L -> expression .
    (56) D -> expression . binary_operator
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    SEMICOLON       reduce using rule 14 (L -> expression .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    binary_operator                shift and go to state 69

state 106

    (15) L -> compound_type_access .

    SEMICOLON       reduce using rule 15 (L -> compound_type_access .)


state 107

    (64) term -> term unary_operator . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    factor                         shift and go to state 121

state 108

    (65) unary_operator -> PLUSPLUS .

    ID              reduce using rule 65 (unary_operator -> PLUSPLUS .)
    NUMBER          reduce using rule 65 (unary_operator -> PLUSPLUS .)
    STRING          reduce using rule 65 (unary_operator -> PLUSPLUS .)
    TRUE            reduce using rule 65 (unary_operator -> PLUSPLUS .)
    FALSE           reduce using rule 65 (unary_operator -> PLUSPLUS .)
    LPAREN          reduce using rule 65 (unary_operator -> PLUSPLUS .)


state 109

    (66) unary_operator -> MINUSMINUS .

    ID              reduce using rule 66 (unary_operator -> MINUSMINUS .)
    NUMBER          reduce using rule 66 (unary_operator -> MINUSMINUS .)
    STRING          reduce using rule 66 (unary_operator -> MINUSMINUS .)
    TRUE            reduce using rule 66 (unary_operator -> MINUSMINUS .)
    FALSE           reduce using rule 66 (unary_operator -> MINUSMINUS .)
    LPAREN          reduce using rule 66 (unary_operator -> MINUSMINUS .)


state 110

    (72) factor -> LPAREN expression . RPAREN
    (56) D -> expression . binary_operator
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    binary_operator                shift and go to state 69

state 111

    (38) if_stmnt -> IF LPAREN condition RPAREN BEGIN . statement_list END T
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    END             reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 123
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 112

    (48) condition -> expression comparison_operator expression .
    (56) D -> expression . binary_operator
    (58) binary_operator -> . PLUS
    (59) binary_operator -> . MINUS
    (60) binary_operator -> . MUL
    (61) binary_operator -> . DIV
    (62) binary_operator -> . REM

    RPAREN          reduce using rule 48 (condition -> expression comparison_operator expression .)
    PLUS            shift and go to state 70
    MINUS           shift and go to state 71
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    REM             shift and go to state 74

    binary_operator                shift and go to state 69

state 113

    (43) while_stmt -> WHILE LPAREN condition RPAREN BEGIN . statement_list END
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    END             reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 124
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 114

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN . BEGIN statement_list RETURN ID SEMICOLON END

    BEGIN           shift and go to state 125


state 115

    (45) parameter_list -> type ID . M
    (46) M -> . COMMA parameter_list
    (47) M -> . empty
    (80) empty -> .

    COMMA           shift and go to state 127
    RPAREN          reduce using rule 80 (empty -> .)

    M                              shift and go to state 126
    empty                          shift and go to state 128

state 116

    (23) N -> LPAREN data . RPAREN

    RPAREN          shift and go to state 129


state 117

    (25) data -> factor . P
    (26) P -> . COMMA data P
    (27) P -> . empty
    (80) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 131
    RPAREN          reduce using rule 80 (empty -> .)
    RSPAREN         reduce using rule 80 (empty -> .)

  ! COMMA           [ reduce using rule 80 (empty -> .) ]

    P                              shift and go to state 130
    empty                          shift and go to state 132

state 118

    (24) N -> LSPAREN data . RSPAREN

    RSPAREN         shift and go to state 133


state 119

    (31) F -> CON LPAREN factor RPAREN .

    SEMICOLON       reduce using rule 31 (F -> CON LPAREN factor RPAREN .)
    RPAREN          reduce using rule 31 (F -> CON LPAREN factor RPAREN .)


state 120

    (36) F -> SUBSTR LPAREN factor COMMA . factor RPAREN
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    factor                         shift and go to state 134

state 121

    (64) term -> term unary_operator factor .

    PLUSPLUS        reduce using rule 64 (term -> term unary_operator factor .)
    MINUSMINUS      reduce using rule 64 (term -> term unary_operator factor .)
    PLUS            reduce using rule 64 (term -> term unary_operator factor .)
    MINUS           reduce using rule 64 (term -> term unary_operator factor .)
    MUL             reduce using rule 64 (term -> term unary_operator factor .)
    DIV             reduce using rule 64 (term -> term unary_operator factor .)
    REM             reduce using rule 64 (term -> term unary_operator factor .)
    SEMICOLON       reduce using rule 64 (term -> term unary_operator factor .)
    RSPAREN         reduce using rule 64 (term -> term unary_operator factor .)
    EQEQ            reduce using rule 64 (term -> term unary_operator factor .)
    NOTEQ           reduce using rule 64 (term -> term unary_operator factor .)
    LT              reduce using rule 64 (term -> term unary_operator factor .)
    GT              reduce using rule 64 (term -> term unary_operator factor .)
    LTEQ            reduce using rule 64 (term -> term unary_operator factor .)
    GTEQ            reduce using rule 64 (term -> term unary_operator factor .)
    RPAREN          reduce using rule 64 (term -> term unary_operator factor .)


state 122

    (72) factor -> LPAREN expression RPAREN .

    PLUSPLUS        reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    MINUSMINUS      reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    MUL             reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    DIV             reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    REM             reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    RSPAREN         reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    NOTEQ           reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 72 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 72 (factor -> LPAREN expression RPAREN .)


state 123

    (38) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list . END T

    END             shift and go to state 135


state 124

    (43) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list . END

    END             shift and go to state 136


state 125

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN . statement_list RETURN ID SEMICOLON END
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    RETURN          reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 137
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 126

    (45) parameter_list -> type ID M .

    RPAREN          reduce using rule 45 (parameter_list -> type ID M .)


state 127

    (46) M -> COMMA . parameter_list
    (45) parameter_list -> . type ID M
    (17) type -> . INT
    (18) type -> . BOOL
    (19) type -> . STR

    INT             shift and go to state 27
    BOOL            shift and go to state 28
    STR             shift and go to state 29

    parameter_list                 shift and go to state 138
    type                           shift and go to state 94

state 128

    (47) M -> empty .

    RPAREN          reduce using rule 47 (M -> empty .)


state 129

    (23) N -> LPAREN data RPAREN .

    SEMICOLON       reduce using rule 23 (N -> LPAREN data RPAREN .)


state 130

    (25) data -> factor P .

    RPAREN          reduce using rule 25 (data -> factor P .)
    RSPAREN         reduce using rule 25 (data -> factor P .)
    COMMA           reduce using rule 25 (data -> factor P .)


state 131

    (26) P -> COMMA . data P
    (25) data -> . factor P
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . STRING
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81
    LPAREN          shift and go to state 82

    data                           shift and go to state 139
    factor                         shift and go to state 117

state 132

    (27) P -> empty .

    RPAREN          reduce using rule 27 (P -> empty .)
    RSPAREN         reduce using rule 27 (P -> empty .)
    COMMA           reduce using rule 27 (P -> empty .)


state 133

    (24) N -> LSPAREN data RSPAREN .

    SEMICOLON       reduce using rule 24 (N -> LSPAREN data RSPAREN .)


state 134

    (36) F -> SUBSTR LPAREN factor COMMA factor . RPAREN

    RPAREN          shift and go to state 140


state 135

    (38) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END . T
    (39) T -> . ELIF LPAREN condition RPAREN BEGIN statement_list END K
    (40) T -> . empty
    (80) empty -> .

    ELIF            shift and go to state 142
    SEMICOLON       reduce using rule 80 (empty -> .)

    T                              shift and go to state 141
    empty                          shift and go to state 143

state 136

    (43) while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .

    SEMICOLON       reduce using rule 43 (while_stmt -> WHILE LPAREN condition RPAREN BEGIN statement_list END .)


state 137

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list . RETURN ID SEMICOLON END

    RETURN          shift and go to state 144


state 138

    (46) M -> COMMA parameter_list .

    RPAREN          reduce using rule 46 (M -> COMMA parameter_list .)


state 139

    (26) P -> COMMA data . P
    (26) P -> . COMMA data P
    (27) P -> . empty
    (80) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 131
    RPAREN          reduce using rule 80 (empty -> .)
    RSPAREN         reduce using rule 80 (empty -> .)

  ! COMMA           [ reduce using rule 80 (empty -> .) ]

    P                              shift and go to state 145
    empty                          shift and go to state 132

state 140

    (36) F -> SUBSTR LPAREN factor COMMA factor RPAREN .

    SEMICOLON       reduce using rule 36 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)
    RPAREN          reduce using rule 36 (F -> SUBSTR LPAREN factor COMMA factor RPAREN .)


state 141

    (38) if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .

    SEMICOLON       reduce using rule 38 (if_stmnt -> IF LPAREN condition RPAREN BEGIN statement_list END T .)


state 142

    (39) T -> ELIF . LPAREN condition RPAREN BEGIN statement_list END K

    LPAREN          shift and go to state 146


state 143

    (40) T -> empty .

    SEMICOLON       reduce using rule 40 (T -> empty .)


state 144

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN . ID SEMICOLON END

    ID              shift and go to state 147


state 145

    (26) P -> COMMA data P .

    RPAREN          reduce using rule 26 (P -> COMMA data P .)
    RSPAREN         reduce using rule 26 (P -> COMMA data P .)
    COMMA           reduce using rule 26 (P -> COMMA data P .)


state 146

    (39) T -> ELIF LPAREN . condition RPAREN BEGIN statement_list END K
    (48) condition -> . expression comparison_operator expression
    (55) expression -> . D term
    (56) D -> . expression binary_operator
    (57) D -> . empty
    (80) empty -> .

    ID              reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    TRUE            reduce using rule 80 (empty -> .)
    FALSE           reduce using rule 80 (empty -> .)
    LPAREN          reduce using rule 80 (empty -> .)

    condition                      shift and go to state 148
    expression                     shift and go to state 55
    D                              shift and go to state 51
    empty                          shift and go to state 52

state 147

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID . SEMICOLON END

    SEMICOLON       shift and go to state 149


state 148

    (39) T -> ELIF LPAREN condition . RPAREN BEGIN statement_list END K

    RPAREN          shift and go to state 150


state 149

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON . END

    END             shift and go to state 151


state 150

    (39) T -> ELIF LPAREN condition RPAREN . BEGIN statement_list END K

    BEGIN           shift and go to state 152


state 151

    (44) function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END .

    SEMICOLON       reduce using rule 44 (function_call -> FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END .)


state 152

    (39) T -> ELIF LPAREN condition RPAREN BEGIN . statement_list END K
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    END             reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 153
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 153

    (39) T -> ELIF LPAREN condition RPAREN BEGIN statement_list . END K

    END             shift and go to state 154


state 154

    (39) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END . K
    (41) K -> . ELSE BEGIN statement_list END
    (42) K -> . empty
    (80) empty -> .

    ELSE            shift and go to state 156
    SEMICOLON       reduce using rule 80 (empty -> .)

    K                              shift and go to state 155
    empty                          shift and go to state 157

state 155

    (39) T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .

    SEMICOLON       reduce using rule 39 (T -> ELIF LPAREN condition RPAREN BEGIN statement_list END K .)


state 156

    (41) K -> ELSE . BEGIN statement_list END

    BEGIN           shift and go to state 158


state 157

    (42) K -> empty .

    SEMICOLON       reduce using rule 42 (K -> empty .)


state 158

    (41) K -> ELSE BEGIN . statement_list END
    (2) statement_list -> . statement SEMICOLON statement_list
    (3) statement_list -> . empty
    (4) statement -> . declaration
    (5) statement -> . assignment
    (6) statement -> . if_stmnt
    (7) statement -> . while_stmt
    (8) statement -> . function_call
    (9) statement -> . compound_types
    (10) statement -> . compound_type_access
    (11) statement -> . try_except
    (12) statement -> . print
    (80) empty -> .
    (13) declaration -> . VAR type ID ASSIGN L
    (16) assignment -> . ID ASSIGN expression
    (38) if_stmnt -> . IF LPAREN condition RPAREN BEGIN statement_list END T
    (43) while_stmt -> . WHILE LPAREN condition RPAREN BEGIN statement_list END
    (44) function_call -> . FUNC ID LPAREN parameter_list RPAREN BEGIN statement_list RETURN ID SEMICOLON END
    (20) compound_types -> . A ID ASSIGN N
    (28) compound_type_access -> . Z F
    (29) compound_type_access -> . ID LSPAREN expression RSPAREN
    (73) try_except -> . TRY x EXCEPT x
    (75) print -> . ZOUT LPAREN y RPAREN
    (21) A -> . TUPLE
    (22) A -> . LIST
    (30) Z -> . ID DOT

    END             reduce using rule 80 (empty -> .)
    VAR             shift and go to state 14
    ID              shift and go to state 15
    IF              shift and go to state 16
    WHILE           shift and go to state 17
    FUNC            shift and go to state 18
    TRY             shift and go to state 21
    ZOUT            shift and go to state 22
    TUPLE           shift and go to state 23
    LIST            shift and go to state 24

    statement_list                 shift and go to state 159
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    if_stmnt                       shift and go to state 7
    while_stmt                     shift and go to state 8
    function_call                  shift and go to state 9
    compound_types                 shift and go to state 10
    compound_type_access           shift and go to state 11
    try_except                     shift and go to state 12
    print                          shift and go to state 13
    A                              shift and go to state 19
    Z                              shift and go to state 20

state 159

    (41) K -> ELSE BEGIN statement_list . END

    END             shift and go to state 160


state 160

    (41) K -> ELSE BEGIN statement_list END .

    SEMICOLON       reduce using rule 41 (K -> ELSE BEGIN statement_list END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 68 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 117 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 139 resolved as shift
